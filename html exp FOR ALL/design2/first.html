<!DOCTYPE html>
<html>
  <head>
    <title>My experiment</title>
    <script src="https://unpkg.com/jspsych@7.3.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.0.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-image-keyboard-response@1.0.0"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="https://unpkg.com/@jspsych/plugin-preload"></script>
    <script src="https://unpkg.com/@jspsych/plugin-survey-text"></script>
    <script src="https://unpkg.com/@jspsych/plugin-fullscreen"></script>
    <script src="https://unpkg.com/@jspsych/plugin-survey-multi-choice"></script>
    <script src="https://unpkg.com/@jspsych/plugin-browser-check"></script>
    <script src="https://unpkg.com/@jspsych/plugin-canvas-keyboard-response@1.1.1"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-csv/0.8.3/jquery.csv.min.js"></script>
    <link href="https://unpkg.com/jspsych@7.0.0/css/jspsych.css" rel="stylesheet" type="text/css" />
    <!-- <script type = "text/javascript" src = "G:/我的云端硬盘/shulai@iu.edu 2022-09-04 14 28/IUB/Project-context/html exp/main.js"></script> -->
    <style>
        table {
            padding-left: 300px;
            padding-right: 300px;
        }
        th, td{
           padding: 20px;
           vertical-align: top
        }
    </style>
  </head>
  <body>
    
  </body>
  
  <script>

    /*************************************************************
     * Author: Shuchun (Lea) Lai
     * Date: 2023-11-15
     *
     * Description: This version include a feedback of correct/incorrect in final test for words with associated list, witha complicated chart
     * 
     * ...
     ************************************************************/

    word_left_file= "https://raw.githubusercontent.com/Shu-Lea-Lai/project-visualmemory-sideexp/master/word_left";
    word_right_file= "https://raw.githubusercontent.com/Shu-Lea-Lai/project-visualmemory-sideexp/master/word_right";
    word_unique_file= "https://raw.githubusercontent.com/Shu-Lea-Lai/project-visualmemory-sideexp/master/word_unique";
    word_left=readTextFile(word_left_file).replace(/\r/g, '').split('\n').slice(0,150);
    word_right=readTextFile(word_right_file).replace(/\r/g, '').split('\n').slice(0,150);
    JT = x=>jsPsych.timelineVariable(x);








///////////////////////////////
    var is_debug = false;
    const timeout_inmin = 120; //70 minutes
    // const timeout = 10;
    const timeout = 1000 * 60 * timeout_inmin ; // 70 minutes in milliseconds
    const is_inst_fullscreen = false;
    const condi = "f";//f, b, r
    const is_showcorrect_inlog = true; //
    const finalfeedback_duration = 500;
    var num_trials_useddebug = 1;//number of tirals show in intial test
    let lastActivityTime = Date.now();
    
    document.body.style.backgroundColor = "white";

    let textFile2 = 'https://raw.githubusercontent.com/Shu-Lea-Lai/project-visualmemory-sideexp/master/ps2.txt';

    let oldids = readTextFile(textFile2).replace(/\r/g, '').split('\n');
    
    function endTrialAfterDuration() {
      jsPsych.finishTrial();
    }
    const trialDurationLimit = 1000;


    
    var jsPsych = initJsPsych({
        on_trial_finish: function(data){
            jsPsych.data.get().addToLast({timepassed_mins: ((Date.now()-lastActivityTime)/1000/60).toFixed(2) });//adding passed time
            data.width =  window.innerWidth;
            data.height = window.innerHeight;
        },
        on_finish: function() {
            // jsPsych.data.displayData();
            // console.log(jsPsych.data.get().last(4).trials[0].testpos_pretest)
            // jsPsych.data.get().localSave('csv', 'ekstra.csv')
            if (jsPsych.data.get().last(4).trials[0].testpos_pretest==420) {
                window.location = "";
                }
            }
        // on_start: function(){
        //   jsPsych.pluginAPI.requestFullscreen();
        // }
    });
    jsPsych.data.addProperties({
                    is_finished: 0, codeversion: 4, is_changedfullscreen: 0})

    //code version 4: change final test instruction and key press

    var timeline = [];
    // jsPsych.data.get().addToAll({condition: condi});
    var subject_id = jsPsych.data.getURLVariable('PROLIFIC_PID');
    var study_id = jsPsych.data.getURLVariable('STUDY_ID');
    var session_id = jsPsych.data.getURLVariable('SESSION_ID');
    
    
    // var condition = condi;

    checknow = window.setInterval(function() {
      const currentTime = Date.now();
    //   console.log(currentTime)
      if (currentTime - lastActivityTime > timeout) {
        alert(`
          Dear participant,

          We regret to inform you that the experiment has been terminated automatically due to an extended period of inactivity. Please close the page to finalize the results. And we kindly request you do not try to do this experiment again.

          We would like to thank you for your participation. Although you were unable to complete this particular experiment, we hope that you will consider joining us for future experiments. Thank you again for your time and effort, you may close the page now.
        `);
        clearInterval(checknow);
        window.onbeforeunload = null;
        window.location="https://www.google.com";
        window.close = true;
        jsPsych.endExperiment();
      }
    }, 1000);
    checknow;

    jsPsych.data.addProperties({
      subject_id: subject_id,
      study_id: study_id,
      session_id: session_id,
      condition: condi
    });

    var enter_fullscreen = {
      // type: jsPsychFullscreen,
      // fullscreen_mode: true
      
      type: jsPsychFullscreen,
      fullscreen_mode: true,
      message: 'To start the experiment, please enter fullscreen mode.'
    
    }

    is_inst_fullscreen? 
    document.addEventListener('fullscreenchange', function(event) {
      if (!document.fullscreenElement) {
        // Handle the case when the user exits fullscreen during the experiment
        // jsPsych.enterFullscreen(); // Re-enter fullscreen
        alert('Please keep the experiment in fullscreen mode. Press F11. Or your data might not be valid');
        jsPsych.data.addProperties({
            is_changedfullscreen: 1
        });
        // timeline.push(enter_fullscreen)
      }
    }) : null;
    
    
    is_inst_fullscreen? window.onbeforeunload = function() {
      return "Do you really want to leave?";
      //if we return nothing here (just calling return;) then there will be no pop-up question at all
      //return;
    } : null;
    
    var browser_check = {
      type: jsPsychBrowserCheck,
      // allow_window_resize: false,
      // minimum_width: 1920,
      // minimum_height: 1080,
      // inclusion_function: (data) => {
      //   return data.browser == 'chrome' && data.mobile === false
      // },
      // exclusion_message: (data) => {
      //   if(data.mobile){
      //     return '<p color: black;background: white;>You must use a desktop/laptop computer to participate in this experiment.</p>';
      //   } else if(data.browser !== 'chrome'){
      //     return '<p color: black;background: white;>You must use Chrome as your browser to complete this experiment.</p>'
      //   }
      // },
      
      on_finish: function(data){
        // window.onbeforeunload = null;
        console.log(data.browser)
        if (!(["chrome","Chrome"].includes(data.browser))){
          // console.log(data.browser)
            alert("You must use Chrome as your browser! You may switch your browser and come back later.")
            window.onbeforeunload = null;
            window.location="https://www.google.com"
            window.close = true
        } else if (data.mobie){
            alert("You must use a desktop/laptop computer to participate in this experiment.")
            window.onbeforeunload = null;
            window.location="https://www.google.com"
            window.close = true
        }
      }
        
    };
    timeline.push(browser_check);
    
    var enterid = {
      type: jsPsychSurveyText,
      questions: [{prompt: "<p color:black>What is your prolific ID?</p>",required:true}],
      on_finish:function(data){
        data.id=data.response["Q0"];
        if (oldids.includes(data.id)) {
            alert(`
            Dear participant,
            
            We have identified that you have previously taken part in one of our research studies, and we sincerely value your prior involvement. Regrettably, we must inform you that you are ineligible to participate in the current study once more.
            
            If you believe this determination to be in error, please do not hesitate to reach out to our research team. We will promptly address your concerns.
            
            Thank you for your understanding.
            `);
            window.onbeforeunload = null;
            window.location="https://www.google.com"
            window.close = true
            jsPsych.endExperiment();
        }
      },
      data: {
        task: "enterid"
      }
    }

    
    // is_inst_fullscreen? timeline.push(enterid) : null; 
    // 
    
    




    var fixation = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: '<div style="font-size:60px;">+</div>',
      choices: "NO_KEYS",
      trial_duration: fixation_duration,
      data: {
        task: 'fixation'
      }
    };

    const average = temparr => {
        if(temparr.length==0) return 0
        else return temparr.reduce((a, b) => a + b) / temparr.length
    };

    function range(start, end)
    {
        var array = new Array();
        for(var i = start; i < end; i++)
        {
            array.push(i);
        }
        return array;
    }

    function copyobj(obj_f){
      return (Object.assign({},obj_f))
    }

    function copyarobj(arobj_f){
      return(range(0,arobj_f.length).map(i=>copyobj(arobj_f[i])))
    }


    // function randomize_ar_inside_nfar(nfar){//randomize 1*1 nonflat ar
    //   return range(0,nfar.length).map(i=>jsPsych.randomization.repeat(copyarobj(nfar[i]),1));
    // }

    // function randomize_ar_inside_nfar(nfar){//randomize 1*1 nonflat ar
    //   return range(0,nfar.length).map(i=>jsPsych.randomization.repeat(nfar[i],1));
    // }
    function randomize_ar_inside_nfar(nfar){//randomize 1*1 nonflat ar
      return range(0,nfar.length).map(i=>jsPsych.randomization.sampleWithoutReplacement(nfar[i],nfar[i].length));
    }

    function readTextFile(file) {

      const rawFile = new XMLHttpRequest();
      let content = null;
      rawFile.open("GET", file, false);
      rawFile.onreadystatechange = function () {
          if (rawFile.readyState === 4) {
              if (rawFile.status === 200 || rawFile.status === 0) {
                  content = rawFile.responseText;
              }
          }
      };
      rawFile.send(null);
      return content;
    };

    function warningfunc(message,timedur){

      var messageDiv = document.createElement("div");
      messageDiv.innerHTML = message;
      // messageDiv.className="jspsych-content-wrapper"
      messageDiv.style.padding = `350px 0`;
      messageDiv.style.textAlign = "center";
      messageDiv.style.margin = "0px"
      // messageDiv.style.height = "100vh";
      messageDiv.style.display = "flex";
      messageDiv.style.justifyContent = "center";
      var exp = document.getElementsByClassName("jspsych-content-wrapper")[0]
      exp.style.visibility = "hidden";
      jsPsych.pauseExperiment() 
      document.body.prepend(messageDiv);
      setTimeout(function() {
        document.body.removeChild(messageDiv); // Remove the div
        exp.style.visibility = "visible";
        jsPsych.resumeExperiment();
      }, timedur);//remove after 1.5s
    }

    function arrsum(ar){return(ar.reduce((a,b)=>a+b,0))};




    // console.log(picnames.findIndex(iobj=>iobj=="Thumbs.db"))
    // console.log(picnames)
    /******************
      Stating constants
      Stating all const variables here
    **********************/
    
    
    if (is_debug) {
      var study_duration = 10;
      var prompt_duration = 10;
      var counting_duration = 10;
      var fixation_duration = 10;
      var counting_gap = 0;
      var posgap_duration = 0;
      var rtfastcut_duration = 0;
      var response_rtlimit_duration = 10;
      var responsekeys = "NO_KEYS";
      var choiceenter = "NO_KEYS";
      var responsekeys_final = "NO_KEYS";
      var instruction_duration = 10; //1 hour 
      var finaltest_rtlimit_duration = 10;
      var warning_duration = 10;
      var feedbackmes_duration = 10;
      var feedbackmes_wordinitial_duration = 5; 
      var feedbackmes_wordfinal_duration = 5; 
      var keychoice_finaltest = "NO_KEYS";
    } else{
      var study_duration = 2000;
      var prompt_duration = 2000;
      var counting_duration = 2000;
      var counting_gap = 1000;
      var fixation_duration = 1000;
      var posgap_duration = 100;
      var rtfastcut_duration = 150;
      var response_rtlimit_duration = 3500; //3.5s to respond each question
      var responsekeys = ['f','j'];
      var choiceenter = 'enter';
      var responsekeys_final = ['s','f','j','l'];
      var instruction_duration = 1000*60*60; //1 hour
      var finaltest_rtlimit_duration = 4000;
      var warning_duration = 1500;
      var feedbackmes_duration = 2000; 
      var feedbackmes_wordinitial_duration = 1000; 
      var feedbackmes_wordfinal_duration = 1000; 
      var keychoice_finaltest = 'p';
    }
    // console.log(fixation_duration)
    const num_digits_pres = 8; // present n digits each trial to fill 24s
    const tot_digit_list_nf = range(0,10).map(i=>jsPsych.randomization.sampleWithReplacement(range(4,10),num_digits_pres)); //create nf easier for final test algorithm coding
    const tot_digit_list = tot_digit_list_nf.flat();
    const tot_correct_sum = range(0,10).map(i=>arrsum(tot_digit_list.slice(i*num_digits_pres,(i+1)*num_digits_pres)));

    // word_left
    // word_right
    // word_unique
    word_pairs_arobj_all = range(0,150).map(i=> {
      left=word_left[i];
      right=word_right[i];
      left_ftl=left.slice(0,2);//first two letters of left
      right_ftl=right.slice(0,2); // first two letters of right
      if (left_ftl!=right_ftl) return (console.log("ERROR!!!!!!"))

      return({
        word_left_i: left,
        word_right_i:right,
        iword: i,
        first_tl_left: left_ftl,
        first_tl_right: right_ftl,
        issame: left_ftl==right_ftl
      })
    }
    )

    word_pairs_arobj_all_rand = jsPsych.randomization.repeat(word_pairs_arobj_all, 1);

    for (let i_list=0;i_list<word_pairs_arobj_all_rand.length; i_list++){
      i_wordobj = word_pairs_arobj_all_rand[i_list];
      i_wordpairs = jsPsych.randomization.sampleWithoutReplacement([i_wordobj.word_left_i,i_wordobj.word_right_i], 2)
      i_wordobj.word_left_i=i_wordpairs[0];
      i_wordobj.word_right_i=i_wordpairs[1];
    }; // this randomize left and right order
    // console.log(word_pairs_arobj_all_rand)



    //10 of 20 length arr
    //Assign AROBJ for all
    ///////////////////////
    var ftl_RPtested_list_i_pairs1 = [];
    var ftl_RPtested_list_i_pairs2 = [];
    const tot_word_arobj_nf = range(0,10).map(i_list=>{

      inum_pairs = Math.floor(i_list/2);//0,1,2,3,4,5
      word_pairs_arobj_i = word_pairs_arobj_all_rand.slice(inum_pairs*30,30+inum_pairs*30);
      new_word_arobj=copyarobj(word_pairs_arobj_i);//copy arobject
      
      //30 pairs used in each list, 10 for repeats, 10+10 for double unique list; List 1,2 share exactly same word_pairs_arobj_i  

      pairs_which_1or2 = i_list % 2 +1 //0 or 1 + 1=1,2 
      
      // word_pairs_RP_arobj_i = new_word_arobj.slice(0,10);      
      test_which_PR = jsPsych.randomization.repeat([1,1,1,0,0,0,0,0,0,0],1);//test three repeats for each list pair
      test_which_nPR = jsPsych.randomization.repeat([1,1,1,1,1,0,0,0,0,0],1);//test five nonrepeats for each list pair
      testpos_pre_rd = jsPsych.randomization.repeat(range(1,9),1);//test 8 item, randomize test position

      if (pairs_which_1or2==1){//if odd
        word_pairs_nRP_arobj_i = new_word_arobj.slice(10,20);
      } else{//else
        word_pairs_nRP_arobj_i = new_word_arobj.slice(20,30);
      }
      word_pairs_RP_arobj_i = copyarobj(new_word_arobj.slice(0,10));

      var itest = 0
      var ftl_RPtested_list_i_paris_1or2 = [];
      for (let irp=0;irp<10;irp++){

          wordobj_nPR_i = word_pairs_nRP_arobj_i[irp];
          wordobj_RP_i = word_pairs_RP_arobj_i[irp];

          // assign wordchosen_initial, and ftl
          wordobj_nPR_i.wordchosen_initial=wordobj_nPR_i.word_left_i;
          if (pairs_which_1or2==1) {
            wordobj_RP_i.wordchosen_initial=wordobj_RP_i.word_left_i;
          }
          else wordobj_RP_i.wordchosen_initial=wordobj_RP_i.word_right_i;
          wordobj_RP_i.ftl=wordobj_RP_i.wordchosen_initial.slice(0,2);
          wordobj_nPR_i.ftl=wordobj_nPR_i.wordchosen_initial.slice(0,2);

          //assign test position and which to be tested
          if (test_which_PR[irp]==1) {
            wordobj_RP_i.is_test = 1;
            wordobj_RP_i.testpos_pretest = testpos_pre_rd[itest];
            ftl_RPtested_list_i_paris_1or2.push(wordobj_RP_i.ftl);
            itest++;
          }
          else {
            wordobj_RP_i.is_test = 0;
            wordobj_RP_i.testpos_pretest = 0;
          }

          if (test_which_nPR[irp]==1) {
            wordobj_nPR_i.is_test = 1;
            wordobj_nPR_i.testpos_pretest = testpos_pre_rd[itest];
            itest++;
          }else{
            wordobj_nPR_i.is_test = 0;
            wordobj_nPR_i.testpos_pretest = 0;
          }
          wordobj_RP_i.wordcondi="repeat";
          wordobj_nPR_i.wordcondi="unique";

        }// end iteration of 1-10
    
      if (pairs_which_1or2==1) ftl_RPtested_list_i_pairs1.push(ftl_RPtested_list_i_paris_1or2);
      else ftl_RPtested_list_i_pairs2.push(ftl_RPtested_list_i_paris_1or2);
      

      word_pairs_arobj_i = word_pairs_RP_arobj_i.concat(word_pairs_nRP_arobj_i);
      for (let ii=0;ii<20;ii++){
        word_pairs_arobj_i[ii].pairs_which_1or2=pairs_which_1or2;
        word_pairs_arobj_i[ii].listnumber_1to10 = i_list+1;
        word_pairs_arobj_i[ii].listgroup_1to5 = inum_pairs+1;//1-5
        
      }
      // console.log(word_pairs_arobj_i)

      return(word_pairs_arobj_i);
    }) ;//end iteration 1-10; end assigning the nf_arobj. 10 foils per trial, get tot_word_arobj_nf





    //assign randomized nfarobj 
    const tot_word_arobj_nf_rd = randomize_ar_inside_nfar(tot_word_arobj_nf);
    range(0,10).map(i=>{
      range(0,20).map(j=>{
      tot_word_arobj_nf_rd[i][j].prespos=j+1;//assign present position to item
    })})
    
    
    // assign if each repeat is tested in pair
    forward_final_ind = range(0,5).map(i=>jsPsych.randomization.repeat(range(i*30+1,30*i+30+1),1));
    backward_final_ind = range(0,5).map(i=>jsPsych.randomization.repeat(range((9-i)*30+1,30*(9-i)+30+1),1));
    randind = jsPsych.randomization.repeat(range(1,30*5+1),1);
    random_final_ind = range(0,5).map(i=>randind.slice(i*30,30*i+30));
    console.log(forward_final_ind,backward_final_ind,random_final_ind)

    if (condi=="f") finalt_ind = forward_final_ind;
    else if (condi=="b") finalt_ind = backward_final_ind;
    else if (condi=="r") finalt_ind = random_final_ind;
    // finalt_ind = finalt_ind.flat();
    console.log(finalt_ind)

    
    for (let i_list=0;i_list<10;i_list++){

      var j_final=0;
      if_pair1 = i_list%2==0;
      inum_pairs = Math.floor(i_list/2);//0,1,2,3,4

      if (if_pair1) {
          arobj_current = tot_word_arobj_nf_rd[i_list]
          arobj_pair = tot_word_arobj_nf_rd[i_list+1]
      }
      else{
          arobj_current = tot_word_arobj_nf_rd[i_list]
          arobj_pair = tot_word_arobj_nf_rd[i_list-1]
      }

      for (let j=0;j<20;j++){

          obj_current = arobj_current[j];
          ftl_oppos_indexinpair = range(0,20).map(inow=>arobj_pair[inow].ftl).findIndex(x=>x==obj_current.ftl); // for each 1, find index in array 2

          if (obj_current.wordcondi=="repeat"){
              correspond_obj_inpair = arobj_pair[ftl_oppos_indexinpair];
              if (correspond_obj_inpair.is_test==1) obj_current.is_test_inpair=1; 
              else obj_current.is_test_inpair=0; 

              obj_current.testpos_inpair=correspond_obj_inpair.testpos_pretest;
              obj_current.prespos_inpair=correspond_obj_inpair.prespos;
              
              if (if_pair1) {//pair1 and pair2 always by word_left and right order
                  pair1 = obj_current;
                  pair2 = correspond_obj_inpair;
              } else {
                  pair1 = correspond_obj_inpair;
                  pair2 = obj_current;
              }

  
              obj_current.wordchosen_inpair1 = pair1.word_left_i;
              obj_current.wordchosen_inpair2 = pair1.word_right_i;
              obj_current.prespos_inpair1 = pair1.prespos;
              obj_current.prespos_inpair2 = pair2.prespos;
              obj_current.testpos_inpair1 = pair1.testpos_pretest;
              obj_current.testpos_inpair2 = pair2.testpos_pretest;
              obj_current.listnumber_1to10_inpair1 = pair1.listnumber_1to10;
              obj_current.listnumber_1to10_inpair2 = pair2.listnumber_1to10;
              obj_current.is_test_inpair1 = pair1.is_test;
              obj_current.is_test_inpair2 = pair2.is_test;
              obj_current.wordchosen_finaltest = [pair1.word_left_i,pair1.word_right_i];
    
              

              if (if_pair1) {
                  obj_current.testpos_final=finalt_ind[inum_pairs][j_final];
                  j_final++
              }
              else {
                  obj_current.testpos_final=correspond_obj_inpair.testpos_final;
              }

          } else if(obj_current.wordcondi=="unique"){
            
            obj_current.is_test_inpair =null;
            obj_current.testpos_inpair  =null;
            obj_current.prespos_inpair1=null;
            obj_current.prespos_inpair2=null;
            obj_current.wordchosen_inpair1 =null;
            obj_current.wordchosen_inpair2 =null;
            obj_current.testpos_inpair1  =null;
            obj_current.testpos_inpair2  =null;

            obj_current.listnumber_1to10_inpair1  =null;
            obj_current.listnumber_1to10_inpair2  =null;
            obj_current.is_test_inpair1  =null;
            obj_current.is_test_inpair2  =null;


            obj_current.testpos_final=finalt_ind[inum_pairs][j_final];
            j_final++;
            obj_current.wordchosen_finaltest = [obj_current.wordchosen_initial];
          }
      }
    }

    console.log("arobj before random",tot_word_arobj_nf)
    console.log("arobj after random",tot_word_arobj_nf_rd)
    console.log("testpos_pretest all extracted",range(0,150).map(i=>{

      if (tot_word_arobj_nf_rd.flat()[i].testpos_final==undefined) console.log(tot_word_arobj_nf_rd.flat()[i])
      return tot_word_arobj_nf_rd.flat()[i].testpos_final
    }))

    //assign test arobj_nf, adding test poisition 
    const tot_word_test_arobj_nf = range(0,10).map(i=>{

      testposarr_ilist = range(0,20).map(j=>tot_word_arobj_nf_rd[i][j].testpos_pretest);
      
      index = range(0,8).map(j=>{//8 test item, 3+5
        return testposarr_ilist.findIndex(x=>x==j+1)
      })
      // console.log(testposarr_ilist,index)
      word_iobj = tot_word_arobj_nf_rd[i];
      return (range(0,8).map(j=>word_iobj[index[j]]))

    })
    console.log("test_initial",tot_word_test_arobj_nf)


    //assign test arobj_nf by excluding repeat in pair2
    const tot_word_finaltest_arobj_temp = range(0,5).map(i_finali=>
    tot_word_arobj_nf_rd[i_finali*2].concat(tot_word_arobj_nf_rd[i_finali*2+1]).filter(x=>!(x.pairs_which_1or2==2&x.wordcondi=="repeat"))).flat();
    

    //arrange order according to final test position
    finalint_flat = finalt_ind.flat();
    index_final = range(0,finalint_flat.length).map(i=>finalint_flat.findIndex(x=>x==i+1))
    const tot_word_finaltest_arobj = range(0,finalint_flat.length).map(i=>tot_word_finaltest_arobj_temp[index_final[i]])
    console.log("finaltest",tot_word_finaltest_arobj);
  

    






    /* Starting exp vars*/
    // console.log(fixation_duration)
    
    var instructions = {
        type: jsPsychSurveyMultiChoice,
        questions: [
          {
          prompt: `<h1 style='text-align: left;color: crimson;background: white;font: caption-;''> INDIANA UNIVERSITY STUDY INFORMATION SHEET FOR RESEARCH MEMORY TEST FOR WORD AND PICTURE </h1> <br>

            <h1 style='color: black;text-align: left;background: white;font: caption;'> You are being asked to participate in a research study. Scientists do research to answer important questions that might help change or improve the way we do things in the future. This document will give you information about the study to help you decide whether you want to participate. Please read this form, and ask any questions you have, before agreeing to be in the study. This study is being conducted under the approval of the Indiana University Institutional Review Board (IRB) with protocol number 18431, including any approved amendments.</h1><br>

            <h1 style='color: black;text-align: left;background: white;font: caption;'> All research is voluntary. You can choose not to take part in this study. If  you decide to participate, you can change your mind later and leave the study at any time. You will not be penalized or lose any benefits if you decide not to participate or choose to leave the study later.</h1> <br> 

            <h1 style='color: black;text-align: left;background: white;font: caption;'> This research is intended for individuals 18 years of age or older. If you are under age 18, do not complete the survey. This research is for residents of the United States. If you are not a U.S. resident, do not complete the survey.</h1> <br> 

            <h1 style='color: black;text-align: left;background: white;font: caption;'> The purpose of this study is to investigate how people remember words and/or pictures.</h1> <br> <h1 style='color: black;text-align: left;background: white;font: caption;'> We are asking you if you want to be in this study because you registered for this study on Prolific. The study is being conducted by Dr. Richard Shiffrin, a professor in the department of Psychological and Brain Science and the Program in Cognitive Science.</h1> <br> 


            
            <h1 style='color: black;text-align: left;background: white;font: caption;'> To protect against loss of confidentiality, any identifiable information from the data that could lead back to you will be removed within two days of your completion of the study.We don’t think you will have any personal benefits from taking part in this study, but we hope to learn things that will help researchers in the future.
            </h1> <br> 
            
            <h1 style='color: black;text-align: left;background: white;font: caption;'><strong><FONT color='#CC5500'> You will be paid for participating in this study.</FONT>We pay at an hourly rate of $10.50, and the payment will be disbursed within 5 days after completing the experiment, there is no cost to participate in this study.<strong> <FONT COLOR="#CC5500"> To be approved and get fully paid, you will have to pay attention to the instructions and show that you could remember some of the words that you study. </FONT> You will receive feedback telling you whether you have been able to remember the words.</strong> </h1><br>

            <h1 style='color: black;text-align: left;background: white;font: caption;'> 
          <strong><FONT color='#CC5500'>If you agree to be in the study, you will do the following things.</FONT> First, the experiment will ask for you to input your ID in Prolific. You must use desktop or PC to do this experiment. You must use <FONT color='#CC5500'> Chrome</FONT> as your browser. In these trials, you will see a list of words to remember. After each list, you will see some digits to add up. Then type the sum. You will then be given the first two letters of a word you studied. If you can remember, type the word that begins with those two letters. </strong> 
          </h1> <br> 
            <h1 style='color: black;text-align: left;background: white;font: caption;'> We will protect your information and make every effort to keep your personal information confidential, but we cannot guarantee absolute confidentiality. No information which could identify you will be shared in publications about this study. Your personal information may be shared outside the research study if required by law. We also may need to share your research records with other groups for quality assurance or data analysis. These groups include the Indiana University Institutional Review Board or its designees, and state or federal agencies who may need to access the research records (as allowed by law). </h1><br>

            <h1 style='color: black;text-align: left;background: white;font: caption;'> If you have questions about the study or encounter a problem with the research, contact the researcher. For questions about the study, contact either Shuchun Lai at shulai@iu.edu , or Dr. Richard Shiffrin at shiffrin@indiana.edu.
            For questions about your rights as a research participant, to discuss problems, complaints, or concerns about a research study, or to obtain information or to offer input, please contact the IU Human Research Protection Program office at 800-696-2949 or at irb@iu.edu. </h1><br>
            
            <h1 style='color: black;text-align: left;background: white;font: caption;'> Thank you for agreeing to participate in our research. Before you begin, please note that the data you provide may be collected and used by Prolific as per its privacy agreement. Additionally, this research is for subjects over the age of 18*; if you are under the age of 18, please do not complete this survey.</h1><br>
            `,
          
          name: 'consent', 
          options: ['I have read and understand this information and agree to join this study'], 
          required: true
          }, 
      ],
    };
    if (is_inst_fullscreen) {
        timeline.push(instructions);
        timeline.push(enter_fullscreen);
    }
    // timeline.push(enterid)
    // timeline.push(instructions)
    

    var fixation = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: '<div style="font-size:60px;">+</div>',
      choices: "NO_KEYS",
      trial_duration: fixation_duration,
      data: {
        task: 'fixation'
      }
    };

    var instructions_practice = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
      <p style='text-align: justify;color: black;background: white;font: caption-;''>(1) A list of words will appear on the screen one at a time. Study the words as they appear.</p>
      <p style='text-align: justify;color: black;background: white;font: caption-;''>(2) Then, after a brief blank period, you will see a series of numbers. Add those as they come, and when you see the words “TYPE THE SUM”, use the number keys to type your answer. </p>
      <p style='text-align: justify;color: black;background: white;font: caption-;''>(3) Then, you will need to recall the words you study one at a time. You will see first two letters of the words you JUST studied presented on screen. Following each presentation, you will need to type in the rest of the words you remembered. </p>
      <p style='text-align: justify;color: black;background: white;font: caption-;''>There will be a practice list followed by 9 lists of words , each followed by a test.</p>
      <p style='text-align: justify;color: black;background: white;font: caption-;''>Do not worry if you were unsure about the words during test.That is normal but make your best guess. </p>
      <p style='text-align: justify;color: black;background: white;font: caption-;''> Please start the practice list now by pressing the enter key. </p>

      `,
      post_trial_gap: posgap_duration,
      trial_duration: instruction_duration,
      choices: choiceenter
    };
    

    var instructions_test = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
      <p style='text-align: justify;color: black;background: white;font: caption-;''>
        Now you have finished the practice. When ready, start the study list with the ‘enter’ key.</p>
      `,
      post_trial_gap: posgap_duration,
      trial_duration: instruction_duration,
      choices: choiceenter
    };

    finalint_text = `<p style='text-align: justify;color: black;background: white;font: caption-;paddingRight =20px; paddingLeft =20px;'>
    
    You have now completed the first part of the study. The next part will test your memory for <strong>ALL</strong> the words you have seen in this study. <br>
    
    You will see two letter cues, just as before, but now there will be <strong>two spaces</strong> to type words beginning with those two letters: <br><br>
    
    For <strong>some</strong> cues you will have seen <strong>only one word</strong> beginning with those letters; and for <strong>some</strong> cues you will have seen </strong>two words</strong> beginning with those letters. <br>
    1. The first blank: <br>(1) If you can <strong>recall one word</strong>, type it in the first space, and then type it in first blank. <br>(2) If you don't remember, type "none". <br> <br>
    2. The second blank: <br>(1) You can then <strong>try to recall a second word</strong> from the study with those letters.  <br>(2)
    You can also type "none" key when you have typed one word and can remember no others, or if there is no word you remembered at all. <br><br>

    3. You will then be shown the <strong>feedback (correct/incorrect) </strong> with word(s) and <strong>the list(s) in which they were studied</strong>. And then will be given the next two letter cue. <br><br>

    Trye to respond as fast and as accurate as possible. <br><br>

    If you have read and understood these new instructions, press the 'p' key to go to the testing.`
        
       

    var instructions_finaltest = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: finalint_text,
      post_trial_gap: posgap_duration,
      trial_duration: instruction_duration,
      choices: keychoice_finaltest
    };
    // timeline.push(instructions_finaltest)


//     /**********************************************************************************
//     trials for tests started
//      **********************************************************************************/
    const num_trials=10;
    timeline_test_all = [];
    for (let i_trial=0; i_trial<num_trials; i_trial++){

   
      const word_arobj_itrial = tot_word_arobj_nf_rd[i_trial];
      const digit_list_itrial = tot_digit_list_nf[i_trial];
      const digits_list_sum_itrial = tot_correct_sum[i_trial];
      const word_test_arobj_itrial = tot_word_test_arobj_nf[i_trial];


      const digit_list_object = range(0,num_digits_pres).map(i=>{
        return {
          digits: digit_list_itrial[i],
          prespos: i+1 //[1,20]
        }
      });

      var ISI = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: '',
        choices: "NO_KEYS",
        trial_duration: 100,
      };   

      /////////////////////////////////////////////////////
      ////////////////// study
      /////////////////////////////////////////////////////

      var prompt_study = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: 'Now you will see the study list, remember the words as they appear',
        choices: "NO_KEYS",
        trial_duration: prompt_duration,
        data:{
          task: "prompt"
        },
        post_trial_gap: posgap_duration
      };

      

      var v_study = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: JT('wordchosen_initial'),
        choices: "NO_KEYS",
        trial_duration: study_duration,
        post_trial_gap: posgap_duration,
        data: {
          task: "pretest_study",
          trialnum: i_trial+1,
          ftl: JT('ftl'),
          is_test: JT('is_test'),
          is_test_inpair: JT('is_test_inpair'),
          is_test_inpair1: JT('is_test_inpair1'),
          is_test_inpair2: JT('is_test_inpair2'),
          listgroup_1to5: JT('listgroup_1to5'),
          listnumber_1to10: JT('listnumber_1to10'),
          listnumber_1to10_inpair1 : JT('listnumber_1to10_inpair1'),
          listnumber_1to10_inpair2 : JT('listnumber_1to10_inpair2'),
          pairs_which_1or2: JT('pairs_which_1or2'),
          prespos: JT('prespos'),
          prespos_inpair1: JT('prespos_inpair1'),
          prespos_inpair2: JT('prespos_inpair2'),
          testpos_pretest: JT('testpos_pretest'),
          testpos_final: JT('testpos_final'),
          testpos_inpair: JT('testpos_inpair'), 
          testpos_inpair1: JT('testpos_inpair1'), 
          testpos_inpair2: JT('testpos_inpair2'), 
          word_left_i: JT('word_left_i'),
          word_right_i: JT('word_right_i'),
          wordchosen_initial: JT('wordchosen_initial'),
          wordchosen_finaltest: JT('wordchosen_finaltest'), 
          wordchosen_inpair1: JT('wordchosen_inpair1'), 
          wordchosen_inpair2: JT('wordchosen_inpair2'), 
          wordcondi: JT('wordcondi')
        }
      };
        

      // console.log(word_arobj_itrial)
      var study_procedure = {
        timeline: [v_study],
        timeline_variables: word_arobj_itrial
      };

      
      /////////////////////////////////////////////////////
      ////////////////// counting
      /////////////////////////////////////////////////////

      var prompt_digits = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: 'Summing up the digits as they appear',
        choices: "NO_KEYS",
        trial_duration: prompt_duration,
        data:{
          task: "prompt"
        },
        post_trial_gap: posgap_duration
      };

      var v_digitpresent = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: JT('digits'),
        choices: "NO_KEYS",
        trial_duration: counting_duration,
        post_trial_gap: counting_gap,
        data: {
          task: "counting", 
          trialnum: i_trial+1
          // prespos: JT('prespos'),
          // stimulus_id: JT('studyimg')
        },
        on_finish: function(data){
          // console.log(digits_list_sum_itrial);
        }
      };
      
      var v_digitresponse_nondebug = {//nondebug

        on_start: function(trial){
            if (is_showcorrect_inlog) console.log("Correct answer:",trial,trial.data.correct_response);
        },
        type: jsPsychSurveyText,
        questions: [
          {prompt: 'Please enter the sum using your number keyboard',required: true}
        ],
        on_finish: function(data){
        //   console.log(digits_list_sum_itrial);
          // console.log(current_digit_response)
          ans = Object.values(data.response)[0]
          data.correct = ans==data.correct_response
          console.log(data.correct_response);
          data.responsesum = ans
        },
        data: {
          task: "counting_response",
          correct_response: digits_list_sum_itrial,
          // is_correct: ;
          trialnum: i_trial+1
        }
      };

      var v_digitresponse_debug = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: "tempdebug",
        on_finish: function(data){
          // console.log(data.response)

        },
        data: {
          task: "counting_response",
          correct_response: digits_list_sum_itrial,
          trialnum: i_trial+1
        },
        choices: "NO_KEYS",
        trial_duration: 100
      };

      if (is_debug) v_digitresponse=v_digitresponse_debug;
      else v_digitresponse = v_digitresponse_nondebug;

      var counting_present_procedure = {
        timeline: [v_digitpresent],
        timeline_variables: digit_list_object
      };

      var countingresponse_feedback_isdigit = {
          timeline: [v_digitresponse],
          loop_function: function(data){

            // console.log()

            if (is_debug) return(false)

            var cur_response = Object.values(data.values()[0].response);
            // console.log(cur_response);
            isdigits = /^[0-9]*$/.test(cur_response);
            // console.log(isdigits);
              if(!isdigits){
                warningfunc(`<div style="text-align:center ; font-size: larger; font-weight: bold; color: black;"><br> <br> <br> <br> <br> Not Digits! </div>`,warning_duration)
                return true;
              } else {

                // currentans = data.values()[0].response;
                return false;
              }
          }
      }

      var prompt_countingfeedback = {//correct and in correct
        on_start: function(){
        },
        type: jsPsychHtmlKeyboardResponse,
        stimulus: function(){

          if(digits_list_sum_itrial==jsPsych.data.get().last(1).values()[0].correct)
            return("<p background:white>CORRECT!</p>")
          else return("<p background:white>INCORRECT!</p>")
        },
        choices: "NO_KEYS",
        trial_duration: feedbackmes_duration,
        data:{
          task: "promptfeedback"
        }, 
        post_trial_gap: posgap_duration
      };


      /////////////////////////////////////////////////////
      ////////////////// test
      /////////////////////////////////////////////////////
      var prompt_recall = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: 'Now recall the words you JUST studied',
        choices: "NO_KEYS",
        trial_duration: prompt_duration,
        data:{
          task: "prompt"
        },
        post_trial_gap: posgap_duration
      };
      

      var v_test = {
        on_start:function(trial){
          console.log(i_trial,JT('wordchosen_initial'),JT('ftl'));
          // trial.data.starttime=Date.now();
          if (is_debug){
            setTimeout(function () {
              jsPsych.finishTrial({
                  response: {
                      question: trial.questions[0].prompt,
                      answer: 'Skipped after ' + (10 / 1000) + ' seconds'
                  },
                  correct: data.word_response == data.wordchosen_initial,
                  is_notremembered: data.word_response == "none",
                  word_response:  ""
              });
            }, 10);
          }
        },
        // trial_duration: response_rtlimit_duration,
        type: jsPsychSurveyText,
        questions: function(){
          ftlnow=JT('ftl');
          return [{prompt: "".concat(`Type <strong>the whole word</strong> you just studied, starting with <strong>"`,ftlnow,`</strong>`,`________:"`,`<br> Type "none" if you don't recall`),
          required:true,
          placeholder:``.concat(`type the word starting with '`,JT('ftl'),`' or 'none'`) 
        }] 
        },
        data:{
          task: 'pretest_response',
          trialnum: i_trial+1,
          ftl: JT('ftl'),
          is_test: JT('is_test'),
          is_test_inpair: JT('is_test_inpair'),
          is_test_inpair1: JT('is_test_inpair1'),
          is_test_inpair2: JT('is_test_inpair2'),
          listgroup_1to5: JT('listgroup_1to5'),
          listnumber_1to10_inpair1 : JT('listnumber_1to10_inpair1'),
          listnumber_1to10_inpair2 : JT('listnumber_1to10_inpair2'),
          listnumber_1to10: JT('listnumber_1to10'),
          pairs_which_1or2: JT('pairs_which_1or2'),
          prespos: JT('prespos'),
          prespos_inpair1: JT('prespos_inpair1'),
          prespos_inpair2: JT('prespos_inpair2'),
          testpos_pretest: JT('testpos_pretest'),
          testpos_final: JT('testpos_final'),
          testpos_inpair: JT('testpos_inpair'), 
          testpos_inpair1: JT('testpos_inpair1'), 
          testpos_inpair2: JT('testpos_inpair2'), 
          word_left_i: JT('word_left_i'),
          word_right_i: JT('word_right_i'),
          wordchosen_initial: JT('wordchosen_initial'),
          wordchosen_finaltest: JT('wordchosen_finaltest'), 
          wordchosen_inpair1: JT('wordchosen_inpair1'), 
          wordchosen_inpair2: JT('wordchosen_inpair2'), 
          wordcondi: JT('wordcondi')
        },
        post_trial_gap: posgap_duration,
        on_finish: function(data){
          if (data.response==null){
            word_response="";
            // data.is_tooslow = 1;
          }else{
            word_response = Object.values(data.response);
            // data.is_tooslow= 0;
          }
          // word_response = data.response==null ? "" : Object.values(data.response);
          data.word_response =  word_response;
          data.is_notremembered = data.word_response == "none";
          data.correct = data.word_response == data.wordchosen_initial;
          // console.log(data.wordchosen_initial,data.correct,data.word_response)
        }
      };
      
      var test_feedback = {
      
        type: jsPsychHtmlKeyboardResponse,
        stimulus: function(){
          lasttrial_obj = jsPsych.data.get().last(1).values()[0];
          // console.log(lasttrial_obj)
          islast_correct = lasttrial_obj.correct;
          // istooslow = lasttrial_obj.is_tooslow;
          last_wordresponse = lasttrial_obj.word_response[0];
          islast_startwithftl = last_wordresponse.slice(0,2)==lasttrial_obj.ftl;
          // console.log("feedback",lasttrial_obj.word_response,islast_startwithftl)
          // console.log("feedback2",islast_startwithftl,lasttrial_obj.is_notremembered)
          if  (!islast_startwithftl&!lasttrial_obj.is_notremembered) feed_note = "<br>Please enter the <strong>FULL</strong> words <strong>starting with the first two letter cues!</strong>";
          else feed_note="";

          // if (istooslow) return "TOO SLOW! You need to response faster!"
          // else{
          // }
          if (islast_correct) return "Correct!".concat(feed_note);
          else return "Incorrect!".concat(feed_note);
          
          // return("ss")
        },
        data:{
          task: 'pretest_feedback'
        },
        post_trial_gap: posgap_duration,
        trial_duration: feedbackmes_wordfinal_duration,
        choices:"NO_KEYS"
      }

      // console.log(word_test_arobj_itrial)
      var test_procedure = {
        // timeline: [v_test,test_feedback],
        timeline: [v_test],
        timeline_variables: word_test_arobj_itrial
      };

      // timeline.push(instructions_practice)
      // timeline.push(prompt_study,fixation,study_procedure)
      // timeline.push(prompt_digits,fixation,counting_present_procedure,countingresponse_feedback_isdigit,prompt_countingfeedback);
      // timeline.push(prompt_recall,fixation,test_procedure);

      // for (i in timeline_test_all) timeline.push(timeline_test_all[i]);
    }


  
  //******************************************************
  //                   Following are final tests
  //******************************************************
  //
  // 
  //
  // 
  //  
  //******************************************************
  




    var v_finaltest = {

      on_start: function(trial){

        if (is_showcorrect_inlog) console.log("Correct answer:",trial.data.wordchosen_finaltest);
        // setTimeout(endTrialAfterDuration, trialDurationLimit*2);
        if (is_debug){
            setTimeout(function () {
              jsPsych.finishTrial({
                  response: {
                      question: trial.questions[0].prompt,
                      answer: 'Skipped after ' + (10 / 1000) + ' seconds'
                  }
              });
            }, 10);
          }
      },
      // trial_duration: finaltest_rtlimit_duration,
      trial_duration: 1000,
      type: jsPsychSurveyText,
      questions: function(){
        ftlnow=JT('ftl');
        return([{
          prompt: "".concat(`Type <strong>the whole word</strong> you studied in <strong>ALL</strong> previous lists, starting with <strong>"`,ftlnow,`</strong>`,`________"<br><br>If you only remember one word, please enter it in the first blank space.<br>`,"<br>The first word if you remember:"),
          placeholder:``.concat(`type the word starting with '`,JT('ftl'),`' or 'none'`),
          required: true
        }, 
        {
          prompt: `The second word if you remember:`,
          placeholder:``.concat(`type the word starting with '`,JT('ftl'),`' or 'none'`),
          required: true
        }])
      },
      data:{
        task: 'finalt_response',
        ftl: JT('ftl'),
        is_test: JT('is_test'),
        is_test_inpair1: JT('is_test_inpair1'),
        is_test_inpair2: JT('is_test_inpair2'),
        listgroup_1to5: JT('listgroup_1to5'),
        listnumber_1to10_inpair1 : JT('listnumber_1to10_inpair1'),
        listnumber_1to10_inpair2 : JT('listnumber_1to10_inpair2'),
        pairs_which_1or2: JT('pairs_which_1or2'),
        prespos: JT('prespos'),
        prespos_inpair1: JT('prespos_inpair1'),
        prespos_inpair2: JT('prespos_inpair2'),
        testpos_pretest: JT('testpos_pretest'), 
        testpos_final: JT('testpos_final'),
        testpos_inpair: JT('testpos_inpair'), 
        testpos_inpair1: JT('testpos_inpair1'), 
        testpos_inpair2: JT('testpos_inpair2'), 
        word_left_i: JT('word_left_i'),
        word_right_i: JT('word_right_i'),
        wordchosen_initial: JT('wordchosen_initial'),
        wordchosen_finaltest: JT('wordchosen_finaltest'), 
        wordchosen_inpair1: JT('wordchosen_inpair1'), 
        wordchosen_inpair2: JT('wordchosen_inpair2'), 
        wordcondi: JT('wordcondi')
      },
      on_finish: function(data){
        console.log(data)
        if (data.response==null){
            word_response="";
            // data.is_tooslow = 1;
        }else{
            word_response = Object.values(data.response);
            // data.is_tooslow= 0;
        }
        // word_response = data.response==null ? [] : Object.values(data.response);
        data.word_response_original = word_response;
        data.word_response = word_response.map(iword=>iword.toLowerCase().replace(/\s/g, ''));
        data.is_repeatanswer = word_response[0]==word_response[1]
        data.wordanswer_first = data.word_response[0];
        data.wordanswer_second = data.word_response[1];
        data.response_numberofnone = word_response.filter(x=>x==="none").length;
        data.is_correct_repeates_condi = data.wordcondi=="repeat" & data.response_numberofnone==0;
        data.is_correct_unique_condi = data.wordcondi=="unique" & data.response_numberofnone==1;
        data.is_repeat_word1_reverse = data.wordanswer_first == data.wordchosen_finaltest[1];
        data.is_repeat_word2_reverse = data.wordanswer_second == data.wordchosen_finaltest[0];
        if (data.wordcondi=="unique"){
          if (data.is_repeat_word2_reverse & !data.is_repeatanswer){//second word correct and not repeat answer
            data.is_correct_first = data.wordanswer_first=="none";
            data.is_correct_second = data.wordanswer_second;
          }else{//if not second correct
            data.is_correct_first = data.wordchosen_finaltest.includes(data.wordanswer_first) & true; //convert to boollen dummy code
            data.is_correct_second = data.wordanswer_second=="none";
          }
        } else if (data.wordcondi=="repeat"){
          data.is_correct_first = data.wordchosen_finaltest.includes(data.wordanswer_first) & true; //convert to boollen dummy code
          data.is_correct_second = data.wordchosen_finaltest.includes(data.wordanswer_second) & !data.is_repeatanswer;
        }

        data.is_bothcorrect = data.is_correct_first&data.is_correct_second;
        // console.log(data.word_response,data.wordanswer_first)
      },
      post_trial_gap: posgap_duration
    };


    var finaltest_feedback = {
      on_start: function(trial){
        console.log("feedback",jsPsych.data.get().last(1).values()[0])
      },
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function(){

        lasttrial_obj = jsPsych.data.get().last(1).values()[0];
        // istooslow = lasttrial_obj.is_tooslow;
        iscorrect1 = lasttrial_obj.is_correct_first ? "CORRECT! " : "INCORRECT! ";
        iscorrect2 = lasttrial_obj.is_correct_second ? "CORRECT! " : "INCORRECT! ";

        //following get word 1 and word 2 for feedback display
        if (lasttrial_obj.wordcondi=='unique'){
          if (lasttrial_obj.is_repeat_word2_reverse & !lasttrial_obj.is_repeatanswer){
            word1="none";
            word2=lasttrial_obj.wordanswer_second;

          }else{

            //first correct only if respond a word;second correct only if respond a word
            word1 = lasttrial_obj.is_correct_first ? lasttrial_obj.wordanswer_first : lasttrial_obj.wordchosen_finaltest[0];
            word2 = lasttrial_obj.is_correct_second ? lasttrial_obj.wordanswer_second : "none";
          }
          
        }else if (lasttrial_obj.wordcondi=="repeat"){
          if (lasttrial_obj.is_correct_first){//if first word correct, the other is correct too or not: find the other 

            word1 = lasttrial_obj.wordanswer_first;
            word2 = lasttrial_obj.is_correct_second ? lasttrial_obj.wordanswer_second : lasttrial_obj.wordchosen_finaltest.filter(x=>x!=word1)[0];
          } else if (!lasttrial_obj.is_correct_first) {
            //first word not correct, the other is correct: correct and find  the other for first; other not correct: in order
            //thus: the other correct: display the other and reversly gives first, 
            //the other incorrect: normally show first and second
            if (lasttrial_obj.is_correct_second){
              word2 = lasttrial_obj.wordanswer_second;
              word1 = lasttrial_obj.wordchosen_finaltest.filter(x=>x!=word2)[0];
            } else {//second word not correct
              word1 = lasttrial_obj.wordchosen_finaltest[0];
              word2 = lasttrial_obj.wordchosen_finaltest[1];
            }
          }
        }

        word2=='none' ? afterword2 = "" : afterword2 = "was seen in <strong><FONT color='red'>list ".concat(tot_word_arobj_nf_rd.flat().find(obj => obj.wordchosen_initial == word2).listnumber_1to10,` </FONT></strong>`);
        word1=='none' ? afterword1 = "" : afterword1 = "was seen in <strong><FONT color='red'>list ".concat(tot_word_arobj_nf_rd.flat().find(obj => obj.wordchosen_initial == word1).listnumber_1to10,` </FONT></strong>`);
        

        responsefeed1 = ``.concat("Word 1: ", `<strong>`,iscorrect1,`</strong>`,`<strong><FONT color='red'>`, word1,` </FONT></strong>`,afterword1)
        responsefeed2 = ``.concat("Word 2: ", `<strong>`,iscorrect2,`</strong>`,`<strong><FONT color='red'>`, word2,` </FONT></strong>`,afterword2)

        //following added to totally rewrite above (almost)
        afterword1 = word1==`none` & lasttrial_obj.is_correct_first ? `<strong><FONT color='red'> none</FONT><strong>` : 'word 1 '.concat("was seen in <strong><FONT color='red'>list ",tot_word_arobj_nf_rd.flat().find(obj => obj.wordchosen_initial == word1).listnumber_1to10,` </FONT></strong>`);
        afterword2 = word2=="none" & lasttrial_obj.is_correct_second ? `<strong><FONT color='red'> none</FONT><strong>` : 'word 2 '.concat("was seen in <strong><FONT color='red'>list ",tot_word_arobj_nf_rd.flat().find(obj => obj.wordchosen_initial == word2).listnumber_1to10,` </FONT></strong>`);
        //finish rewritting


        responsefeed1 = ``.concat("Word 1: ", `<strong>`,iscorrect1,`</strong>`,afterword1)
        responsefeed2 = ``.concat("Word 2: ", `<strong>`,iscorrect2,`</strong>`,afterword2)
        // console.log(lasttrial_obj.wordchosen_finaltest)
        // console.log(capitalizeStringinArr(lasttrial_obj.wordchosen_finaltest))
        return ``.concat(responsefeed1,`<br>`,responsefeed2)
      },
      data:{
        task: 'finalt_feedback',
        ftl: JT('ftl'),
        is_test: JT('is_test'),
        is_test_inpair1: JT('is_test_inpair1'),
        is_test_inpair2: JT('is_test_inpair2'),
        listgroup_1to5: JT('listgroup_1to5'),
        listnumber_1to10_inpair1 : JT('listnumber_1to10_inpair1'),
        listnumber_1to10_inpair2 : JT('listnumber_1to10_inpair2'),
        pairs_which_1or2: JT('pairs_which_1or2'),
        prespos: JT('prespos'),
        prespos_inpair1: JT('prespos_inpair1'),
        prespos_inpair2: JT('prespos_inpair2'),
        testpos_pretest: JT('testpos_pretest'), 
        testpos_final: JT('testpos_final'),
        testpos_inpair: JT('testpos_inpair'), 
        testpos_inpair1: JT('testpos_inpair1'), 
        testpos_inpair2: JT('testpos_inpair2'), 
        word_left_i: JT('word_left_i'),
        word_right_i: JT('word_right_i'),
        wordchosen_initial: JT('wordchosen_initial'),
        wordchosen_finaltest: JT('wordchosen_finaltest'), 
        wordchosen_inpair1: JT('wordchosen_inpair1'), 
        wordchosen_inpair2: JT('wordchosen_inpair2'), 
        wordcondi: JT('wordcondi')
        // trialnum: 
      },
      trial_duration: feedbackmes_wordinitial_duration,
      choices:"NO_KEYS",
      post_trial_gap: posgap_duration
      // choices:"enter"
    }

    var finaltest_procedure = {
      timeline: [v_finaltest,finaltest_feedback],
      timeline_variables: tot_word_finaltest_arobj,
      on_finish: function(data){
        data.timelasted=Date.now()-lastActivityTime;
      }
    };

    var final_instruction = {
      on_start: function(trial){
        window.onbeforeunload = null;
        nownow = jsPsych.data.get().select('recognition_correct');
        jsPsych.data.addProperties({
            all_accumulated_accuracy: average(nownow.values)
        });
      },
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function(){
        nownow = average(jsPsych.data.get().select('recognition_correct').values);

        return "<p color:black>YOU FINISHED!<p><p color: black>Your overall accumulated accuracy is: <strong>".concat(
          Math.round(nownow*100)).concat(
            `%</strong><p> <p color:black>You will get a completion code if you hit 'enter'.  You could decide if you want to return your completion code.<p>`)
      },
      // stimulus: `<p>You've finished the last task. Thanks for participating!</p>
        // <p><a href="https://app.prolific.co/submissions/complete?cc=C2P9U8QZ">Click here to return to Prolific and complete the study</a>.</p>`,
      choices: 'enter',
      data:{
        task:"instruction"
      },
      on_finish: function(data){
        jsPsych.data.get().localSave('csv', 'ekstra.csv');
        jsPsych.endExperiment();
        // jsPsych.endExperiment();
      }
    }


    var exit_fullscreen = {
      type: jsPsychFullscreen,
      fullscreen_mode: false,
      delay_after: 0
    }

    var final_trial = initJsPsych({
      on_finish: function(){
      
        window.location = "https://app.prolific.co/submissions/complete?cc=C2P9U8QZ";
        jsPsych.endExperiment();
      }
    });

    timeline.push(instructions_finaltest,finaltest_procedure);
    // timeline.push(instructions_finaltest,finaltest_procedure);
    timeline.push(exit_fullscreen,final_instruction);
    
    
    jsPsych.run(timeline);

    // let desiredOrder = ["stimulus", "trial_type", "response", "trial_number"];

    // // Create a new object with the desired order
    // let reorderedData = {};

    // desiredOrder.forEach(key => {
    //   if (jsPsychData.hasOwnProperty(key)) {
    //     reorderedData[key] = jsPsychData[key];
    //   }
    // });



  </script>
</html>