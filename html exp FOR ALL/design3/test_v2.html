<!DOCTYPE html>
<html>
    <head>
        <title>My experiment</title>
        <script src="https://unpkg.com/jspsych@7.3.3"></script>
        <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.0.0"></script>
        <script src="https://unpkg.com/@jspsych/plugin-image-keyboard-response@1.0.0"></script>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
        <script src="https://unpkg.com/@jspsych/plugin-preload@1.1.3"></script>
        <script src="https://unpkg.com/@jspsych/plugin-survey-text@1.1.3"></script>
        <script src="https://unpkg.com/@jspsych/plugin-fullscreen@1.2.1"></script>
        <script src="https://unpkg.com/@jspsych/plugin-survey-multi-choice@1.1.3"></script>
        <script src="https://unpkg.com/@jspsych/plugin-browser-check@1.0.3"></script>
        <script src="https://unpkg.com/@jspsych/plugin-canvas-keyboard-response@1.1.1"></script>
        <script src="https://unpkg.com/@jspsych/plugin-html-button-response@1.2.0"></script>
        <link href="https://unpkg.com/jspsych@7.0.0/css/jspsych.css" rel="stylesheet" type="text/css" />
        <!-- <script type = "text/javascript" src = "G:/我的云端硬盘/shulai@iu.edu 2022-09-04 14 28/IUB/Project-context/html exp/main.js"></script> -->
    </head>
    <body>
        
    </body>
    
    <script>
        //the latest version 3.28
        //test_v2.html is finished, it's a doc with all prior-assigned variable algorithm written done. There might be mistakes happened, but I'll keep this file closed and saved as an unchanging version. 

        /******
         * This version is modified based on test.html. The last file coded a basic testing exp. It gives the initial test structure => 
         * having the nested timeline without having the arr objects having the same type of trials to be jammed into one variable .    
         * 
        ******/
        JT = x=>jsPsych.timelineVariable(x);
        JRR = (x,y)=>jsPsych.randomization.repeat(x,y);

        let textFile = 'https://raw.githubusercontent.com/Shu-Lea-Lai/project-visualmemory-sideexp/master/picnames.txt';
        let textFile2 = 'https://raw.githubusercontent.com/Shu-Lea-Lai/project-visualmemory-sideexp/master/ps.txt';
        let rtf = readTextFile(textFile);
        let rnl = rtf.replace(/\r/g, '');
        var picnames = rnl.split('\n').slice(0,2362-1); 
        const picdir = 'https://raw.githubusercontent.com/Shu-Lea-Lai/project-visualmemory-sideexp/master/images/';

        const fixation_duration = 500;
        // console.log(picnames)

        picdir_arr = picnames.map(iname=> picdir+iname)


        var jsPsych = initJsPsych({
            on_trial_finish: function(data){
                // jsPsych.data.get().addToLast({timepassed_mins: ((Date.now()-lastActivityTime)/1000/60).toFixed(2) });//adding passed time
                data.width =  window.innerWidth;
                data.height = window.innerHeight;
            },
            on_finish: function() {
                // jsPsych.data.displayData();
                // console.log(jsPsych.data.get().last(4).trials[0].testPos_appear1_initial)
                // jsPsych.data.get().localSave('csv', 'ekstra.csv')
                // if (jsPsych.data.get().last(4).trials[0].testPos_appear1_initial==420) {
                //     window.location = "";
                //     }
                }
        });

        var fixation = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: '<div style="font-size:60px;">+</div>',
            choices: "NO_KEYS",
            trial_duration: fixation_duration,
            data: {
                task: 'fixation'
            }
            };

        
        timeline=[];

        /******
         * CONST var assignment here
        ******/
        const condi='r'; 
        const picnames_rand = JRR(picnames,1); 

        const n_lists_singular = 10;//number of lists
        const n_itemInUnit_singular = 3; //3 items in each category. This haven't been converge this var to Int
        const n_itemInUnit_final_singular = n_itemInUnit_singular-1;//number

        const n_NumAllUnit_exceptOverlapInCurrentList_InUnitScale_perList_singular =  15;//15 units of pictures used current list
        const n_NumAllItem_exceptOverlapInCurrentList_InItemScale_perList_singular =  n_NumAllUnit_exceptOverlapInCurrentList_InUnitScale_perList_singular * n_itemInUnit_singular;//45 pictures used current list, regardless of from prior or not
        const n_imageStudyOrTest_perList_inUnitScale_singular = n_NumAllUnit_exceptOverlapInCurrentList_InUnitScale_perList_singular * (2/3); // 10 unit of tests 
        const n_imageStudyOrTest_perList_inItemScale_singular = n_imageStudyOrTest_perList_inUnitScale_singular*n_itemInUnit_singular; //30 tests
        // (portion) of item used in each category
        const finalTest_PortionItemUseInType_singular = 2/3; 
        const n_howMuchMoreUnitSpecialForList1_inUnitScale_forFnn_forAll_singular = 3; //3 more units in list 1, and all that is from Fn; 

        // size_inList_inUnitScale_newInList [a,b] is the how many unit (each unit of size 3) of that kind is needed AS NEW is in each list. a is that for list 1, and b is that for all the rest list.
        //nInType_allList is the number of item across all lists (in current experiment) of the current type 
            const Design_TypeAll_objOfObj = {
                A:{
                    size_inList_inUnitScale_newInList:[4,4], 
                    nInType_allList:n_itemInUnit_singular*n_lists_singular*4,
                    type_comment: "studied only, not in trial",
                    type_code_studiedCurr: 1, 
                    type_code_testiedCurr: 0, 
                    type_code_testiedNext: 0
                },
                B:{
                    size_inList_inUnitScale_newInList:[4,4],
                    nInType_allList:n_itemInUnit_singular*n_lists_singular*4,
                    type_comment: "current target, not in next trial",
                    type_code_studiedCurr: 1, 
                    type_code_testiedCurr: 1, 
                    type_code_testiedNext: 0
                },
                Dn:{
                    size_inList_inUnitScale_newInList:[1,1],
                    nInType_allList:n_itemInUnit_singular*n_lists_singular*1,
                    type_comment: "current target, in next trial",
                    type_code_studiedCurr: 1, 
                    type_code_testiedCurr: 1, 
                    type_code_testiedNext: 1
                },
                Cn:{
                    size_inList_inUnitScale_newInList:[1,1],
                    nInType_allList:n_itemInUnit_singular*n_lists_singular*1,
                    type_comment: "studied only, in next trial",
                    type_code_studiedCurr: 1, 
                    type_code_testiedCurr: 0, 
                    type_code_testiedNext: 1
                },
                Fnn:{
                    size_inList_inUnitScale_newInList:[1,1],
                    nInType_allList:n_itemInUnit_singular*n_lists_singular*1,
                    type_comment: "tested only, in next trial",
                    type_code_studiedCurr: 0, 
                    type_code_testiedCurr: 1, 
                    type_code_testiedNext: 1
                },
                Fn:{
                    size_inList_inUnitScale_newInList:[4,1], //list 1 have 3 unit, the rest have 1 unit,
                    nInType_allList:n_itemInUnit_singular*n_lists_singular*1 + 3*n_itemInUnit_singular,
                    type_comment: "tested only, not in next trial",
                    type_code_studiedCurr: 0, 
                    type_code_testiedCurr: 1, 
                    type_code_testiedNext: 0
                }
            }
            const nType_singular = Object.keys(Design_TypeAll_objOfObj).length; //6 types
            const TypeNames_arr = Object.keys(Design_TypeAll_objOfObj); //All names
            const n_eachTypeSize_InWholeExp_inItemScale_arr = range(0,nType_singular).map(i=>{return(Design_TypeAll_objOfObj[TypeNames_arr[i]].nInType_allList)}); //[120, 120, 30, ...]

            const n_sumNewInEachList_inUnitScale_list1_singular = n_NumAllUnit_exceptOverlapInCurrentList_InUnitScale_perList_singular;//15; number of new item needed in each list (in a unit scaling). It yeilds a single value - 15 here
            const n_sumNewInEachList_inUnitScale_listRested_singular = n_sumNewInEachList_inUnitScale_list1_singular - n_howMuchMoreUnitSpecialForList1_inUnitScale_forFnn_forAll_singular; // 12 here

            const n_newInList_inItemScale_arr = [n_sumNewInEachList_inUnitScale_list1_singular*n_itemInUnit_singular,...JRR(n_sumNewInEachList_inUnitScale_listRested_singular*n_itemInUnit_singular,n_lists_singular-1)]; // [15*3, 12*3, 12*3...12*3]
            const n_fromPriorInList_inItemScale_arr = [0,...JRR(n_howMuchMoreUnitSpecialForList1_inUnitScale_forFnn_forAll_singular*n_itemInUnit_singular , n_lists_singular-1)];//[0,3*3, 3*3...]

            // const n_fromPriorList_inItemScale_2ElementArr_List1_ListRest = [n_NumAllUnit_exceptOverlapInCurrentList_InUnitScale_perList_singular - ] 
            
            // const n_fromPriorList_inItemScale = n_newInList_inItemScale_arr.map(inow=>inow)

            const n_newInEachList_inItemScale_final_arr = n_newInList_inItemScale_arr.map(inow=>inow*finalTest_PortionItemUseInType_singular); //[10*3, 8*3,8*3,... ]    *2/3 times 2 because there are new Foil in final
            const n_newInEachList_plusFinalFoil_inItemScale_final_arr = n_newInEachList_inItemScale_final_arr.map(inow=>inow*2); //[10*3*2, 8*3*2,8*3*2,... ] times 2 because double foil
            console.log("n_newInEachList_plusFinalFoil_inItemScale_final_arr",n_newInEachList_plusFinalFoil_inItemScale_final_arr)
            

            
            const n_itemFinalTest_singular = sum(n_newInEachList_plusFinalFoil_inItemScale_final_arr) ; //=480; sum all numbers in the array

            // forward and backward list order (reverse outer array
            const finalTestIndex_forward_arr = generateTestPositions(n_newInEachList_plusFinalFoil_inItemScale_final_arr);//e.g., [[2,1...] ,[14,11,...],]
            const finalTestIndex_backward_arr = [...finalTestIndex_forward_arr].reverse();
            const finalTestIndex_random_flat_arr = shuffledRange(n_itemFinalTest_singular)
            const finalTestIndex_random_arr = n_newInEachList_plusFinalFoil_inItemScale_final_arr.reduce(
                ([res, i], size) => [ [...res, finalTestIndex_random_flat_arr.slice(i, i + size)], i + size ],
                [[], 0]
            )[0]; //making the flat array to become a nested one like the two above

            let finalTestIndex_arr;//this store and the next will be popped
            //check the following if it assigns globally
            if (condi==='f') finalTestIndex_arr = finalTestIndex_forward_arr;
            if (condi==='b') finalTestIndex_arr = finalTestIndex_backward_arr;
            if (condi==='r') finalTestIndex_arr = finalTestIndex_random_arr;
            const finalTestIndex_arr_copy =  [...finalTestIndex_arr];


            console.log("finalTestIndex_forward_arr",finalTestIndex_forward_arr)
            console.log("finalTestIndex_backward_arr",finalTestIndex_backward_arr)
            console.log("finalTestIndex_random_arr",finalTestIndex_random_arr)

            // const n_A = n_itemInUnit_singular*n_lists_singular*4;
            // const n_B = n_itemInUnit_singular*n_lists_singular*4;
            // const n_Dn = n_itemInUnit_singular*n_lists_singular*1;
            // const n_Cn = n_itemInUnit_singular*n_lists_singular*1;
            // const n_Fnn = n_itemInUnit_singular*n_lists_singular*1;
            // const n_Fn = n_itemInUnit_singular*n_lists_singular*1 + 3*n_itemInUnit_singular;//39
            // const n_eachTypeSize_InWholeExp_inItemScale_arr=[n_A,n_B,n_Dn,n_Cn,n_Fnn,n_Fn];
            // const TypeNames_arr=['n_A','n_B','n_Dn','n_Cn','n_Fnn','n_Fn'];


            
        /******
         * Algorithems below
        ******/
            const picnames_rand_ChunkObj_MasterPool_objOfArr = chunkToObject(picnames_rand,n_eachTypeSize_InWholeExp_inItemScale_arr,TypeNames_arr); //[]
            console.log("picnames_rand_ChunkObj_MasterPool_objOfArr",picnames_rand_ChunkObj_MasterPool_objOfArr);
            console.log('Design_TypeAll_objOfObj',Design_TypeAll_objOfObj)
            
            // Initialize arrays, its key would be the types and its value would an object be the intialized 
            // typeArry = type : obj 
            //this is the time when the object is firstly initialized. 
            const typeArrays =  Object.fromEntries(TypeNames_arr.map(name => [name, []]));

            // console.log('now',picnames_rand_ChunkObj_MasterPool_objOfArr)
            // let nitem_list1;
            for (const type of Object.keys(picnames_rand_ChunkObj_MasterPool_objOfArr)) {

                const TC = Design_TypeAll_objOfObj[type].type_comment;
                const Code1 = Design_TypeAll_objOfObj[type].type_code_studiedCurr;
                const Code2 = Design_TypeAll_objOfObj[type].type_code_testiedCurr;
                const Code3 = Design_TypeAll_objOfObj[type].type_code_testiedNext;
                const size_inList_inUnitScale_newInList = Design_TypeAll_objOfObj[type].size_inList_inUnitScale_newInList;

                for (let i = 0; i < n_lists_singular; i++) {
                    // Slice correct portion

                    //The following step initialize the listItems array in making it have the correct number items and an id of each item of each list 
                    let listItems;
                    //Warning right here, check later if error
                    nitem_list1 =  size_inList_inUnitScale_newInList[0] * n_itemInUnit_singular; //store for later easier use
                    if (i==0){ //list 1, special right here
                        listItems = picnames_rand_ChunkObj_MasterPool_objOfArr[type].slice(0, nitem_list1);
                    }else{
                        listItems = picnames_rand_ChunkObj_MasterPool_objOfArr[type].slice( nitem_list1 + (i-1)*size_inList_inUnitScale_newInList[1]*n_itemInUnit_singular, nitem_list1 + i*size_inList_inUnitScale_newInList[1]*n_itemInUnit_singular);
                    }

                    const n_useCurrentTypeInList = Math.floor(listItems.length * finalTest_PortionItemUseInType_singular); 
                    const allIndices = Array.from({ length: listItems.length }, (_, inow) => inow);//give array of length n, array values to be inow (1 to n), bassically range(1,n)

                    // Shuffle the index array and pick first n_useCurrentTypeInList
                    const finalTestIndices = allIndices.sort(() => Math.random() - 0.5).slice(0, n_useCurrentTypeInList);
                    const chosenFinalSet = new Set(finalTestIndices);

                    // console.log("type",type,"i",i)
                    // console.log("listitems",listItems)
                    // Map into objects
                    // console.log("type",finalTestIndices,chosenFinalSet,listItems)
                    const listObjects = listItems.map((id_picName, idx) => ({
                        type_comment: TC,
                        type_code_studiedCurr : Code1,
                        type_code_testiedCurr : Code2,
                        type_code_testiedNext : Code3,
                        id_picName: id_picName,
                        stimulusConditions : type, //condition for the whole exp, ABC, etc
                        wordcondi : condi,
                        anRepeatedItem: ['Cn','Dn','Fnn'].includes(type) ? true : false,
                        current_assignmentTypesWithinList: null,//Target/Foil in  current list
                        listNum_firstAppear: i+1,
                        currentTask: null,//study/test
                        studyPos_appear1_initial: null,
                        testPos_appear1_initial: null,
                        is_studied_appear1_initial: null,
                        is_tested_appear1_initial: null,
                        studyPos_appear2_initial: null,
                        testPos_appear2_initial: null,
                        is_studied_appear2_initial: null,
                        is_tested_appear2_initial: null,
                        studyPos_appear0_initial: null,
                        testPos_appear0_initial: null,
                        is_studied_appear0_initial: null,
                        is_tested_appear0_initial: null,
                        is_currentObjAppear1: null,
                        num_CurrObjAppear: null,
                        testPos_final: null,//initialize to be 0
                        name_nPlusOneTrial: null,//initialize to be 0
                        is_chosenFinal: chosenFinalSet.has(idx), //same above
                        listNum_currTest: null
                    }));
                    typeArrays[type].push(listObjects);
                }
            }

            console.log('typeArrays',typeArrays);



        //example: [ [ {}, {}, ... 30 ], ...10 ];  // 10 lists of 30 study objects
        let study_lists_arrArrObj_inUse = [];//array of objects
        let test_lists_arrArrObj_inUse = [];
        
        let AllTargetFinalPos_store_map = new Map();
        // console.log("Ss",typeArrays)

        for (let ilist = 0; ilist < n_lists_singular; ilist++){
            // console.log("first",ilist)
            // Combine items for this list
            const A_items = typeArrays.A[ilist];
            const B_items = typeArrays.B[ilist];
            const Cn_items = typeArrays.Cn[ilist];
            const Dn_items = typeArrays.Dn[ilist];
            const Fn_items = typeArrays.Fn[ilist];
            const Fnn_items = typeArrays.Fnn[ilist];
            const Dn_priorList_items = ilist!==0 ? typeArrays.Dn[ilist-1] : undefined; 
            const Cn_priorList_items = ilist!==0 ? typeArrays.Fnn[ilist-1] : undefined;
            const Fnn_priorList_items = ilist!==0 ? typeArrays.Fnn[ilist-1] : undefined;

            // Define study and test for this list
            const study = deepcopyarobj(shuffleArray([...A_items, ...B_items, ...Cn_items, ...Dn_items]));//Cn,Dn goes to next; A, B current 
            const test = deepcopyarobj(shuffleArray(
                ilist === 0
                    ? [...B_items, ...Dn_items, ...Fn_items, ...Fnn_items]
                    : [...B_items, ...Dn_items, ...Fn_items, ...Fnn_items, ...Dn_priorList_items, ...Cn_priorList_items, ...Fnn_priorList_items]
            ));//(B Dn) from current; (Fnn_l,Cn_l,Dn,l) from last list; (Fn, Fnn) current new            

            //In the following, I will assign types with their n+1 trial name:
            // A, Cn+1, B, Dn+1 || B, Dn+1, Dn, Cn, Fnn+1, Fn+1, Fnn 
            // let icount = 0;
            study.forEach((obj, idx) => {//only type A, Cn, B, Dn

                obj.listNum_currTest = ilist+1;
                currAssign = obj.stimulusConditions;
                if (['B','A'].includes(currAssign)){
                    obj.name_nPlusOneTrial = currAssign;
                }else if (['Cn','Dn'].includes(currAssign)){
                    obj.name_nPlusOneTrial = currAssign + "+1";
                }

                if (['f','r'].includes(condi)){
                    obj.testPos_final = obj.is_chosenFinal ? finalTestIndex_arr[ilist].pop(1) : 0;
                    obj.listNum_currTest =  obj.is_chosenFinal ? ilist : 0;
                    // icount ++;
                }else if ('b'===condi){
                    if (['A','B'].includes(obj.name_nPlusOneTrial)){
                        obj.testPos_final = obj.is_chosenFinal ? finalTestIndex_arr[ilist].pop(1) : 0;
                    }else if (['Cn+1','Dn+1'].includes(condi)) {
                        obj.testPos_final = "don't konow yet";
                        if (ilist === (n_lists_singular-1)){
                            obj.testPos_final = finalTestIndex_arr[ilist].pop(1);
                        }
                        //Cn+1, Dn+1 find testposition in next test pos
                    }
                }
                
                obj.current_assignmentTypesWithinList = ['A','Cn'].includes(obj.stimulusConditions) ? "target" : "nontarget"; // keep this for now
                obj.is_currentObjAppear1 = true;
                obj.num_CurrObjAppear = 1;

                obj.studyPos_appear1_initial = idx + 1;
                obj.testPos_appear1_initial = obj.current_assignmentTypesWithinList==="target" ? test.findIndex(iobj=>iobj.id_picName===obj.id_picName)+1 : 0;
                obj.is_studied_appear1_initial = true;
                obj.is_tested_appear1_initial = obj.testPos_appear1_initial === 0 ? false : true;

                obj.studyPos_appear2_initial = 0;
                obj.testPos_appear2_initial = obj.anRepeatedItem ? "don't know here, assign later" : 0;
                obj.is_studied_appear2_initial = false;
                obj.is_tested_appear2_initial = obj.anRepeatedItem ? "don't know here, assign later" : false; 

                obj.studyPos_appear0_initial = obj.studyPos_appear1_initial;
                obj.testPos_appear0_initial = obj.testPos_appear1_initial;
                obj.is_studied_appear0_initial = obj.is_studied_appear1_initial;
                obj.is_tested_appear0_initial = obj.is_tested_appear1_initial;

                obj.currentTask = "study";
            });

            // A, Cn+1, B, Dn+1 || B, Dn+1, Dn, Cn, Fnn+1, Fn+1, Fnn 
            // console.log(study,test)
            test.forEach((obj, idx) => {
                
                obj.listNum_currTest = ilist+1;
                crrObjListNum_jsidx = obj.listNum_firstAppear -1;

                currAssign = obj.stimulusConditions;
                if (['B','Fn'].includes(currAssign)){
                    obj.name_nPlusOneTrial = currAssign;
                }else if (['Cn','Dn','Fnn'].includes){

                    if (crrObjListNum_jsidx === ilist){
                        obj.name_nPlusOneTrial = currAssign + "+1" ;
                    }else{
                        obj.name_nPlusOneTrial = currAssign
                        obj.type_comment = obj.type_comment + ", from last trial"
                    }
                     //when ilist=1; all obj listNum_firstAppear=1,thus no item is named Cn, Dn or Fnn, they are all named Cn+1, Dn+1, Fnn+1, so they won't go through the following finding of [ilist-1], the following code doesn't have a problem
                }

                if (['f','r'].includes(condi)){
                    if (['Fnn+1','Fn+1'].includes(obj.name_nPlusOneTrial)){
                        obj.testPos_final = obj.is_chosenFinal ? finalTestIndex_arr[ilist].pop(1) : 0;
                        obj.listNum_currTest = obj.is_chosenFinal ? ilist : 0
                        // icount ++;
                    }else if (['B','Dn+1'].includes(obj.name_nPlusOneTrial)){
                        obj.testPos_final = study.find(istudy=>istudy.id_picName === obj.id_picName).testPos_final;//tricky findout here
                    }else if (['Dn','Fnn'].includes(obj.name_nPlusOneTrial)){
                        obj.testPos_final = test_lists_arrArrObj_inUse[ilist-1].find(itest=>itest.id_picName === obj.id_picName).testPos_final;
                    }else if ('Cn'===obj.name_nPlusOneTrial){
                        obj.testPos_final = study_lists_arrArrObj_inUse[ilist-1].find(istudy=>istudy.id_picName === obj.id_picName).testPos_final;
                    }

                    
                }else if ('b'===condi){
                    if (['Dn','Cn','Fnn','Fn+1'].includes(obj.name_nPlusOneTrial)){
                        obj.testPos_final =   obj.is_chosenFinal ? finalTestIndex_arr[ilist].pop(1) : 0;
                        // icount ++;
                    }else if ('B' === condi){
                        obj.testPos_final = study.find(istudy=>istudy.id_picName = obj.id_picName).testPos_final;
                    }else if (['Fnn+1','Dn+1'].includes(obj.name_nPlusOneTrial)){
                        obj.testPos_final = "don't know yet";
                        if (ilist === (n_lists_singular-1)){
                            obj.testPos_final = obj.name_nPlusOneTrial === 'Fnn+1' ? finalTestIndex_arr[ilist].pop(1) : study.find(istudy=>istudy.id_picName = obj.id_picName).testPos_final;
                        }
                    }
                }

                // is_currentObj_PriorItem = obj.listNum_firstAppear !== ilist;
                obj.current_assignmentTypesWithinList = ['B','Dn'].includes(obj.stimulusConditions) &&  crrObjListNum_jsidx===ilist ? "target" : "foil";
                obj.is_currentObjAppear1 = crrObjListNum_jsidx === ilist; 
                // console.log(il)

                if (obj.is_currentObjAppear1) { //list 1 only go throug this condition 

                    obj.num_CurrObjAppear = 1;
                    obj.studyPos_appear1_initial = study.findIndex(iobj=>iobj.id_picName===obj.id_picName)+1;
                    obj.testPos_appear1_initial = idx + 1;
                    obj.is_studied_appear1_initial = obj.studyPos_appear1_initial === 0 ? false : true;
                    obj.is_tested_appear1_initial = true;

                    obj.studyPos_appear2_initial = 0; 
                    obj.testPos_appear2_initial = obj.anRepeatedItem ? "don't know here, assign later" : 0;//restricted to only type 'Cn+1','Dn+1'
                    obj.is_studied_appear2_initial = false;
                    obj.is_tested_appear2_initial = obj.anRepeatedItem ? "don't know here, assign later" : false; 

                    obj.studyPos_appear0_initial = obj.studyPos_appear1_initial;
                    obj.testPos_appear0_initial = obj.testPos_appear1_initial;
                    obj.is_studied_appear0_initial = obj.is_studied_appear1_initial;
                    obj.is_tested_appear0_initial = obj.is_tested_appear1_initial;
                }else{//only possible to be Dn, Cn, Fnn, when they were the second appear
                    // console.log(ilist,obj,study_lists_arrArrObj_inUse[ilist-1].find(iobj=>iobj.id_picName===obj.id_picName))
                    obj.num_CurrObjAppear=2;
                    if (obj.name_nPlusOneTrial !== "Fnn"){
                        obj.studyPos_appear1_initial = study_lists_arrArrObj_inUse[ilist-1].find(iobj=>iobj.id_picName===obj.id_picName).studyPos_appear1_initial;
                    }else{
                        obj.studyPos_appear1_initial = 0;
                    }

                    if (obj.name_nPlusOneTrial !== "Cn"){
                        obj.testPos_appear1_initial = test_lists_arrArrObj_inUse[ilist-1].find(iobj=>iobj.id_picName===obj.id_picName).studyPos_appear1_initial;
                    }else{
                        obj.testPos_appear1_initial = 0;
                    }
                    obj.is_studied_appear1_initial = obj.studyPos_appear1_initial === 0 ? false : true;
                    obj.is_tested_appear1_initial = obj.testPos_appear1_initial === 0 ? false : true;

                    obj.studyPos_appear2_initial = 0;
                    obj.testPos_appear2_initial = idx + 1;
                    obj.is_studied_appear2_initial = false;
                    obj.is_tested_appear2_initial = true; 

                    obj.studyPos_appear0_initial = obj.studyPos_appear2_initial;
                    obj.testPos_appear0_initial = obj.testPos_appear2_initial;
                    obj.is_studied_appear0_initial = obj.is_studied_appear2_initial;
                    obj.is_tested_appear0_initial = obj.is_tested_appear2_initial;
                }

                obj.currentTask = "test";
            });
 
            study_lists_arrArrObj_inUse.push(study);
            test_lists_arrArrObj_inUse.push(test);
        };

        console.log("studylist",study_lists_arrArrObj_inUse)
        console.log("testlist",test_lists_arrArrObj_inUse)
        

        //Assign testPos_appear2_initial = obj.anRepeatedItem ? "don't know here, assign later" : 0;
        /// is_tested_appear2_initial
        //Though maybe a single property function call could handle the following task, the for loop is kept and used because more stuff might be add in later in this part. A for loop will be easier for later usage. 

        // let finalTest_lists_arrObj_flat = [];
        // let finalTestPositionSet = new Map();
        let finalTestPositionSet = new Set();
        let finalTest_lists_arrObj_flat = [];
        for (let n = 0; n < n_lists_singular ; n++) {

            concat_arr = [...study_lists_arrArrObj_inUse[n], ...test_lists_arrArrObj_inUse[n]];
            // finalTestMapOfMap_ListKey.set(n,concat_arr)
            if (n < n_lists_singular - 1){
                const nextTestList = test_lists_arrArrObj_inUse[n + 1];

                // Create a map: id → index in next test list
                const nextTestMap = new Map();
                nextTestList.forEach((obj, idx) => {
                    nextTestMap.set(obj.id_picName, obj);
                });
                
                // Now go through current list's study and test objects,
                // Assign the next list test pos in both study and test 
                // testPos_appear2_initial
                for (const obj of concat_arr){

                    //use this map allIdentical_FinalTestPos_Map to forbid final pos overlap.
                    if(!finalTestPositionSet.has(obj.testPos_final)){
                        // finalTestPositionSet.set(obj.testPos_final, obj);
                        finalTestPositionSet.add(obj.testPos_final);
                        finalTest_lists_arrObj_flat.push(obj)
                    }

                    const nextObj = nextTestMap.get(obj.id_picName);
                    obj.testPos_appear2_initial = nextObj ? nextObj.testPos_appear1_initial : 0;
                    obj.is_tested_appear2_initial = nextObj ? nextObj.testPos_appear1_initial !==0  : false;

                    if (condi==="b"){ //this could be moved to the previous for loop as well, but is instead written here for better clarity
                        if (['Cn+1','Dn+1','Fnn+1'].includes(obj.name_nPlusOneTrial)){
                            obj.testPos_final = nextObj.testPos_final;
                        };
                    }
                }
            }else{//list 10
                for (const obj of concat_arr){
                    if(!finalTestPositionSet.has(obj.testPos_final)){
                        finalTestPositionSet.add(obj.testPos_final);
                        finalTest_lists_arrObj_flat.push(obj)
                    }
                    obj.testPos_appear2_initial = 0;
                }
            };

        };

        //The following is a little mistaken right now because it is a flat array. 
        let finalTest_lists_arrArrObj_inUse = deepcopyarobj(finalTest_lists_arrObj_flat);
        const propertiesToRemove = ['is_currentObjAppear1',"is_studied_appear0_initial","is_tested_appear0_initial","listNum_currTest","name_nPlusOneTrial","num_CurrObjAppear","studyPos_appear0_initial","testPos_appear0_initial"]
        //type comment here is kept but is a little mistaken for the last part "from last trial";
        for (const obj of study_lists_arrArrObj_inUse) {
            obj.currentTask = "finaltest";
            propertiesToRemove.forEach(prop => delete obj[prop]);
        };




        const list1_study = [
            { image: picdir_arr[1] },
            { image: picdir_arr[2] },
            // ...
            { image: picdir_arr[3] }
            ];

        const list1_test = [
        { image: picdir_arr[2], correct_response: 'f' },
        { image: picdir_arr[3], correct_response: 'j' },
        // ...
        { image: picdir_arr[5], correct_response: 'f' }
        ];

        const list2_study = [
            { image: picdir_arr[1] },
            { image: picdir_arr[2] },
            // ...
            { image: picdir_arr[3] }
            ];

        const list2_test = [
        { image: picdir_arr[2], correct_response: 'f' },
        { image: picdir_arr[3], correct_response: 'j' },
        // ...
        { image: picdir_arr[5], correct_response: 'f' }
        ];

        const all_lists = [
        { study: list1_study, test: list1_test },
        { study: list2_study, test: list2_test }
        ];

        const study_trial = {
            type: jsPsychImageKeyboardResponse,
            stimulus: jsPsych.timelineVariable('image'),
            choices: [' '],
            trial_duration: 1000
            };

        const test_trial = {
            type: jsPsychImageKeyboardResponse,
            stimulus: jsPsych.timelineVariable('image'),
            choices: ['f', 'j'],
            data: {
                correct_response: jsPsych.timelineVariable('correct_response')
            }
            };
        
        const test_timeline = all_lists.map(list => {
            return {
                timeline: [
                {//The following are comparable to push the 'final' stuff into the timeline variable; as if creating a new timeline varible element
                    timeline: [study_trial],
                    timeline_variables: list.study,
                    randomize_order: false
                },
                {
                    timeline: [test_trial],
                    timeline_variables: list.test,
                    randomize_order: false
                }
                ]
            };
            });
        
        
        timeline.push(test_timeline)
        //// EXPERIMENT START
        /////The followings are just a test
        






        timeline.push(fixation);
        jsPsych.run(timeline.flat());


        //********************************************************************************************************
    //                    Functions
    //********************************************************************************************************
    //
    // Brief description of this section and its purpose.
    // Additional details or important information.
    // List of key tasks or functions performed here.
    //
    //********************************************************************************************************

//the following shuffles array while changes it's original copy
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));  // pick a random index <= i
    [array[i], array[j]] = [array[j], array[i]];    // swap
  }
  return array;
};

function shuffledRange(n) {
  const arr = Array.from({ length: n }, (_, i) => i);
  for (let i = n - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
};


function repeatedArray(x,a) {return Array.from({ length: a }, () => x)};

function generateTestPositions(lengths) {//input an array with lengthens of each subarray
  let currentPos = 0;
  let result = [];

  // Loop through the lengths array
  for (let i = 0; i < lengths.length; i++) {
    const subArrayLength = lengths[i];

    // Generate continuous range for the current subarray
    let range = [];
    for (let j = currentPos; j < currentPos + subArrayLength; j++) {
      range.push(j);
    }

    // Shuffle the positions inside the subarray
    range = shuffleArray(range);

    // Add the shuffled positions to the result array
    result.push(range);

    // Update the current position for the next subarray
    currentPos += subArrayLength;
  }

  return result;
}

function average(arr) {
    const sum = arr.reduce((acc, value) => {
        // Convert boolean to 0 or 1 for calculation
        const numericValue = typeof value === 'boolean' ? (value ? 1 : 0) : value;
        return acc + numericValue;
    }, 0);

    return sum / arr.length;
}

function sum(arr) {
  return arr.reduce((acc, num) => acc + num, 0);
}


function range(start, end)
{
    var array = new Array();
    for(var i = start; i < end; i++)
    {
        array.push(i);
    }
    return array;
}

    function deepcopyobj(obj_f){
    return (Object.assign({},obj_f))//this could've been done better with spread operator ...
    }

    function deepcopyarobj(arobj_f){
    return(range(0,arobj_f.length).map(i=>deepcopyobj(arobj_f[i])))
    }
    function randomize_ar_inside_nfar(nfar){//randomize 1*1 nonflat ar
    return range(0,nfar.length).map(i=>jsPsych.randomization.sampleWithoutReplacement(nfar[i],nfar[i].length));
    }   

function chunkToObject(arr, sizes, names) {
  if (sizes.length !== names.length) {
    throw new Error("Mismatch between number of sizes and names");
  }

  const result = {};
  let index = 0;

  for (let i = 0; i < sizes.length; i++) {
    result[names[i]] = arr.slice(index, index + sizes[i]);
    // result[names[i]] = 'sss';
    index += sizes[i];
  }

  return result;
}

function readTextFile(file) {

    const rawFile = new XMLHttpRequest();
        let content = null;
        rawFile.open("GET", file, false);
        rawFile.onreadystatechange = function () {
            if (rawFile.readyState === 4) {
                if (rawFile.status === 200 || rawFile.status === 0) {
                    content = rawFile.responseText;
                }
            }
        };
        rawFile.send(null);
        return content;
};

function warningfunc(message,timedur){

    var messageDiv = document.createElement("div");
    messageDiv.innerHTML = message;
    // messageDiv.className="jspsych-content-wrapper"
    messageDiv.style.padding = `350px 0`;
    messageDiv.style.textAlign = "center";
    messageDiv.style.margin = "0px"
    // messageDiv.style.height = "100vh";
    messageDiv.style.display = "flex";
    messageDiv.style.justifyContent = "center";
    var exp = document.getElementsByClassName("jspsych-content-wrapper")[0]
    exp.style.visibility = "hidden";
    jsPsych.pauseExperiment() 
    document.body.prepend(messageDiv);
    setTimeout(function() {
        document.body.removeChild(messageDiv); // Remove the div
        exp.style.visibility = "visible";
        jsPsych.resumeExperiment();
    }, timedur);//remove after 1.5s
}

function arrsum(ar){return(ar.reduce((a,b)=>a+b,0))};

function combinedReorderArray(reorder) {
    // let reverseReorder = reorder;
    let original = new Array(reorder.length);
    let original2 = new Array(reorder.length);
    let left = 0;
    let right = reorder.length - 1;

    for (let i = 0; i < reorder.length; i += 2) {
        if (left == right) {
            original[left] = original2[left] = reorder[i];
        } else {
            original[left] = original2[right] = reorder[i];
            // Ensure we don't go out of bounds when the original array has an odd length
            if (i + 1 < reorder.length) {
                original[right] = original2[left] = reorder[i + 1];
            }
        }
        left++;
        right--;
    }

    return [original,original2];
}



function startExperimentTimer() {

    const experimentTimerInterval = window.setInterval(function() {

        const currentTime = Date.now();
        if (currentTime - lastActivityTime > timeout) {
        alert(`
            Dear participant,

            We regret to inform you that the experiment has been terminated automatically due to exceeding the allowed time. Please close the page to finalize the results. And we kindly request you not to attempt this experiment again.

            We would like to thank you for your participation. Although you were unable to complete this particular experiment, we hope that you will consider joining us for future experiments. Thank you again for your time and effort; you may close the page now.
        `);
        clearInterval(experimentTimerInterval);
        console.log(currentTime - lastActivityTime);
        window.onbeforeunload = null;
        window.location = "https://www.google.com";
        window.close = true;
        jsPsych.endExperiment();
        }
    }, 1000);
}

    </script>