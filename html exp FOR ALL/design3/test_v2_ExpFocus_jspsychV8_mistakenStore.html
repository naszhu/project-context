<!DOCTYPE html>
<html>
    <head>
        <title>My experiment</title>
        <!-- <script src="https://unpkg.com/jspsych@7.3.3"></script> -->
        <!-- <script src="https://unpkg.com/jspsych@8.2.1"></script>
        <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.0.0"></script>
        <script src="https://unpkg.com/@jspsych/plugin-image-keyboard-response@1.0.0"></script>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
        <script src="https://unpkg.com/@jspsych/plugin-preload@1.1.3"></script>
        <script src="https://unpkg.com/@jspsych/plugin-survey-text@1.1.3"></script>
        <script src="https://unpkg.com/@jspsych/plugin-fullscreen@1.2.1"></script>
        <script src="https://unpkg.com/@jspsych/plugin-survey-multi-choice@1.1.3"></script>
        <script src="https://unpkg.com/@jspsych/plugin-browser-check@1.0.3"></script>
        <script src="https://unpkg.com/@jspsych/plugin-canvas-keyboard-response@1.1.1"></script>
        <script src="https://unpkg.com/@jspsych/plugin-html-button-response@1.2.0"></script> -->
                
        <!-- <link href="https://unpkg.com/jspsych@7.0.0/css/jspsych.css" rel="stylesheet" type="text/css" /> -->

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
        <script src="jspsych/jspsych.js"></script>
        <script src="jspsych/plugin-html-keyboard-response.js"></script>
        <script src="jspsych/plugin-image-keyboard-response.js"></script>
        <script src="jspsych/plugin-preload.js"></script>
        <script src="jspsych/plugin-survey-text.js"></script>
        <script src="jspsych/plugin-fullscreen.js"></script>
        <script src="jspsych/plugin-survey-multi-choice.js"></script>
        <script src="jspsych/plugin-browser-check.js"></script>
        <script src="jspsych/plugin-canvas-keyboard-response.js"></script>
        <script src="jspsych/plugin-html-button-response.js"></script>
        
        <link href="jspsych/jspsych.css" rel="stylesheet" type="text/css" />
        <!-- <script type = "text/javascript" src = "G:/我的云端硬盘/shulai@iu.edu 2022-09-04 14 28/IUB/Project-context/html exp/main.js"></script> -->
    </head>
    <body>
        
    </body>
    
    <script>
        //the latest version 3.28
        //modified from finalized version of test_v2.html, where the pre-assigned algorithms of the variables have been done.  
        /******
         * This version is modified based on test.html. The last file coded a basic testing exp. It gives the initial test structure => 
         * having the nested timeline without having the arr objects having the same type of trials to be jammed into one variable .    
         * 
         * 
         * This version has finished on writting an inital test (possible errors could occur), next version shift to jspsych v8
         * 
         * was editing line395
        ******/
        JT = x=>jsPsych.timelineVariable(x);
        JRR = (x,y)=>jsPsych.randomization.repeat(x,y);

        var is_debug = true; //!!
        const is_inst_fullscreen = false;//!!
        const is_showcorrect_inlog = false; //!!
        const timeout_inmin = 120; //100 minutes
        const codeversion_begins = 1;//!!
        const timelimit_finalinst=1000*30;//check this in curr file. 
        const timelimit_initial_inst = 1000*1;//check this, it's how much time compulsive is for the instructions initial 
        const timeout = 1000 * 60 * timeout_inmin ; // 70 minutes in milliseconds
        const condi='r'; 
        console.log("current condition:", condi)
        var num_trials_useddebug = 1;//number of tirals show in intial test
        let lastActivityTime = Date.now();

        document.body.style.backgroundColor = "white";
        var styleElement = document.createElement('style');
    

        // Hide continue button in text filling, but I don't think I need this in curr file.
        var cssRules = `
            /* Hide the Continue button */
            .jspsych-btn {
            display: none !important;
            margin: 0 auto;
            }

            .jspsych-html-button-response-button .jspsych-btn {
            display: block !important; /* or 'inline-block', 'flex', etc. */
            }
        `;

        // Append the CSS rules to the style element
        styleElement.appendChild(document.createTextNode(cssRules));

        // Append the style element to the document head
        document.head.appendChild(styleElement);


        let textFile = 'https://raw.githubusercontent.com/Shu-Lea-Lai/project-visualmemory-sideexp/master/picnames.txt';
        let textFile2 = 'https://raw.githubusercontent.com/Shu-Lea-Lai/project-visualmemory-sideexp/master/ps.txt';
        let rtf = readTextFile(textFile);
        let rnl = rtf.replace(/\r/g, '');
        var picnames = rnl.split('\n').slice(0,2362-1); 
        const picdir = 'https://raw.githubusercontent.com/Shu-Lea-Lai/project-visualmemory-sideexp/master/images/';
        const picdir_arr = picnames.map(iname=> picdir+iname)

        // let oldids = readTextFile(textFile2).replace(/\r/g, '').split('\n');
        // console.log(oldids)

        function endTrialAfterDuration() {
            jsPsych.finishTrial(); //Check this in v8
        }
        const trialDurationLimit = 1000;



        var jsPsych = initJsPsych({
            on_trial_finish: function(data){
                jsPsych.data.get().addToLast({timepassed_mins: ((Date.now()-lastActivityTime)/1000/60).toFixed(2) });//adding passed time
                // if (jsPsych.data.get().last(1).trials[0].testPos_final==num_tottest_finaltest && jsPsych.data.get().last(1).trials[0].task==="finalt_response") {
                //     jsPsych.data.addProperties({
                //         is_finished: 1
                // })};
                data.width =  window.innerWidth;
                data.height = window.innerHeight;
            },
            on_finish: function() {

                lasttestpos = jsPsych.data.get().select("testPos_final").values;
                console.log(lasttestpos)
                //Check below
                // if (lasttestpos[lasttestpos.length-1]==num_tottest_finaltest) {
                //     console.log("sucess!!")
                //     window.location = confirmid;
                //     }
                }
        // on_start: function(){
        //   jsPsych.pluginAPI.requestFullscreen();
        // }
        });

        
        var timeline=[];
        var subject_id = jsPsych.data.getURLVariable('PROLIFIC_PID');
        var study_id = jsPsych.data.getURLVariable('STUDY_ID');
        var session_id = jsPsych.data.getURLVariable('SESSION_ID');

        startExperimentTimer()

        jsPsych.data.addProperties({
            subject_id: subject_id,
            study_id: study_id,
            session_id: session_id,
            condition: condi,
            is_finished: 0,
            codeversion: codeversion_begins, 
            is_changedfullscreen: 0, 
            designversion:2
        });

        if (is_debug) {
            var study_duration = 10;
            var initial_test_duration = 10;
            var prompt_duration = 10;
            var prompt_finaltestlist_duration = 10;
            var counting_duration = 10;
            var fixation_duration = 10;
            var counting_gap = 0;
            var posgap_duration = 0;
            var rtfastcut_duration = 0;
            var response_rtlimit_duration = 10;
            var responsekeys = "NO_KEYS";
            var choiceenter = "NO_KEYS";
            var responsekeys_final = "NO_KEYS";
            var instruction_duration = 10; //1 hour 
            var instruction_duration_between = 10;//10 minutes   
            var finaltest_rtlimit_duration = 10;
            var warning_duration = 10;
            var feedbackmes_duration = 10;
            var feedbackmes_wordinitial_duration = 5; 
            var feedbackmes_wordfinal_duration = 5; 
            var keychoice_finaltest = "NO_KEYS";
        } else{
            var study_duration = 2000;
            var initial_test_duration = 3500; //remember to assign 
            var prompt_duration = 2000;
            var prompt_finaltestlist_duration = 3000;
            var counting_duration = 2000;
            var counting_gap = 1000;
            var fixation_duration = 1000;
            var posgap_duration = 100;
            var rtfastcut_duration = 150;
            var response_rtlimit_duration = 3500; //3.5s to respond each question
            var responsekeys = ['f','j'];
            var choiceenter = 'enter';
            var responsekeys_final = ['s','f','j','l'];
            var instruction_duration = 1000*60*60; //1 hour
            var instruction_duration_between = 10*60*60;//10 minutes   
            var finaltest_rtlimit_duration = 4000;
            var warning_duration = 1500;
            var feedbackmes_duration = 1500; 
            var feedbackmes_wordinitial_duration = 700; //intial test feedback length
            var feedbackmes_wordfinal_duration = 2000; //final test feedback length
            var keychoice_finaltest = 'enter';
        }

    //****************************************************
    //                    CONST var assignment here
    //****************************************************
    // 
    // 
    // 
    // 
    //****************************************************


        const picnames_rand = JRR(picnames,1); 

        const n_lists_singular = 10;//number of lists
        const n_itemInUnit_singular = 3; //3 items in each category. This haven't been converge this var to Int
        const n_itemInUnit_final_singular = n_itemInUnit_singular-1;//number

        const n_NumAllUnit_exceptOverlapInCurrentList_InUnitScale_perList_singular =  15;//15 units of pictures used current list
        const n_NumAllItem_exceptOverlapInCurrentList_InItemScale_perList_singular =  n_NumAllUnit_exceptOverlapInCurrentList_InUnitScale_perList_singular * n_itemInUnit_singular;//45 pictures used current list, regardless of from prior or not
        const n_imageStudyOrTest_perList_inUnitScale_singular = n_NumAllUnit_exceptOverlapInCurrentList_InUnitScale_perList_singular * (2/3); // 10 unit of tests or 10 unit of studies 
        const n_imageStudyOrTest_perList_inItemScale_singular = n_imageStudyOrTest_perList_inUnitScale_singular*n_itemInUnit_singular; //30 tests or 30 studies
        // (portion) of item used in each category
        const finalTest_PortionItemUseInType_singular = 2/3; 
        const n_howMuchMoreUnitSpecialForList1_inUnitScale_forFnn_forAll_singular = 3; //3 more units in list 1, and all that is from Fn;


        const num_digits_pres = 8; // present n digits each trial to fill 24s
        const digit_list_nonfalt = range(0,n_lists_singular).map(i=>jsPsych.randomization.sampleWithReplacement(range(4,10),num_digits_pres)); //create nf easier for final 
        const digit_totCorrect_sum = digit_list_nonfalt.map(i=>arrsum(i));
        const digit_totCorrect_sum_arrObj_inUse = digit_totCorrect_sum.map((i,iidx)=>{
            return({
            sum_currList : i,
            listNum_currTest_initial: iidx + 1
        })
        })
        console.log("digit_totCorrect_sum_arrObj_inUse",digit_totCorrect_sum_arrObj_inUse)
        console.log("digit_list_nonfalt,digit_totCorrect_sum---followed next",digit_list_nonfalt,digit_totCorrect_sum)
        const digit_list_arrArrObj_inUse = digit_list_nonfalt.map((i,iidx)=>i.map((j, jidx)=>{return({
            digit_value : j,
            presPos : jidx+1,
            sum_currList: digit_totCorrect_sum[iidx],
            listNum_currTest_initial: iidx + 1
        })}))
        console.log("digit_list_arrArrObj_inUse",digit_list_arrArrObj_inUse)


        /*************************************************
         *  size_inList_inUnitScale_newInList [a,b] is the how many unit (each unit of size 3) of that kind is needed AS NEW is in each list. a is that for list 1, and b is that for all the rest list.
         * nInType_allList is the number of item across all lists (in current experiment) of the current type 
         * 
         * size_inList_inUnitScale_newInList: applies for initial test number of new items in each list , 
         *          and applies for forward and random condition of number items patching in each list 
         * nInType_allList: is the number of typeX item across the whole experiment 
         *          (they need to be patched with double times, but the patched item have type "FF")   
         * size_inList_inUnitScale_newPosFinal [a,b,c]]: 
         *      a is that special for list1, 
         *      b is that special for list 2 to (n-1),
         *      c is that special for list n
         * 
         * Check the picture of written chart of final test assignment in each list each kind for more info 
         * 
         * sum of size_inList_inUnitScale_newPosFinal_f_r equals sum of size_inList_inUnitScale_newPosFinal_b
        ***********************************************/
        const Design_TypeAll_objOfObj_initial = {
            A:{
                size_inList_inUnitScale_newInList:[4,4], 
                size_inList_inUnitScale_newPosFinal_f_r: [4,4,4],
                size_inList_inUnitScale_newPosFinal_b: [4,4,4],
                nInType_allList:n_itemInUnit_singular*n_lists_singular*4,
                type_comment: "studied only, not in trial",
                type_code_studiedCurr: 1, 
                type_code_testiedCurr: 0, 
                type_code_testiedNext: 0
            },
            B:{
                size_inList_inUnitScale_newInList:[4,4],
                size_inList_inUnitScale_newPosFinal_f_r: [4,4,4],
                size_inList_inUnitScale_newPosFinal_b: [4,4,4],
                nInType_allList:n_itemInUnit_singular*n_lists_singular*4,
                type_comment: "current target, not in next trial",
                type_code_studiedCurr: 1, 
                type_code_testiedCurr: 1, 
                type_code_testiedNext: 0
            },
            Dn:{
                size_inList_inUnitScale_newInList:[1,1],
                size_inList_inUnitScale_newPosFinal_f_r: [1,1,1],
                size_inList_inUnitScale_newPosFinal_b: [0,1,2],
                nInType_allList:n_itemInUnit_singular*n_lists_singular*1,
                type_comment: "current target, in next trial",
                type_code_studiedCurr: 1, 
                type_code_testiedCurr: 1, 
                type_code_testiedNext: 1
            },
            Cn:{
                size_inList_inUnitScale_newInList:[1,1],
                size_inList_inUnitScale_newPosFinal_f_r: [1,1,1],
                size_inList_inUnitScale_newPosFinal_b: [0,1,2],
                nInType_allList:n_itemInUnit_singular*n_lists_singular*1,
                type_comment: "studied only, in next trial",
                type_code_studiedCurr: 1, 
                type_code_testiedCurr: 0, 
                type_code_testiedNext: 1
            },
            Fnn:{
                size_inList_inUnitScale_newInList:[1,1],
                size_inList_inUnitScale_newPosFinal_f_r: [1,1,1],
                size_inList_inUnitScale_newPosFinal_b: [0,1,2],
                nInType_allList:n_itemInUnit_singular*n_lists_singular*1,
                type_comment: "tested only, in next trial",
                type_code_studiedCurr: 0, 
                type_code_testiedCurr: 1, 
                type_code_testiedNext: 1
            },
            Fn:{
                size_inList_inUnitScale_newInList:[4,1], //list 1 have 3 unit, the rest have 1 unit,
                size_inList_inUnitScale_newPosFinal_f_r: [4,1,1],
                size_inList_inUnitScale_newPosFinal_b: [4,1,1],
                nInType_allList:n_itemInUnit_singular*n_lists_singular*1 + 3*n_itemInUnit_singular,
                type_comment: "tested only, not in next trial",
                type_code_studiedCurr: 0, 
                type_code_testiedCurr: 1, 
                type_code_testiedNext: 0
            }
        }
        const nType_singular = Object.keys(Design_TypeAll_objOfObj_initial).length; //6 types
        const TypeNames_arr = Object.keys(Design_TypeAll_objOfObj_initial); //All names
        const n_eachTypeSize_InWholeExp_inItemScale_arr = range(0,nType_singular).map(i=>{return(Design_TypeAll_objOfObj_initial[TypeNames_arr[i]].nInType_allList)}); //[120, 120, 30, 30, 30, 39]
        const Map_NameToTypeSize_initial = new Map(TypeNames_arr.map((key,idx)=>[key, n_eachTypeSize_InWholeExp_inItemScale_arr[idx]]));

        const n_sumNewInEachList_inUnitScale_list1_singular = n_NumAllUnit_exceptOverlapInCurrentList_InUnitScale_perList_singular;//15; number of new item needed in each list (in a unit scaling). It yeilds a single value - 15 here
        const n_sumNewInEachList_inUnitScale_listRested_singular = n_sumNewInEachList_inUnitScale_list1_singular - n_howMuchMoreUnitSpecialForList1_inUnitScale_forFnn_forAll_singular; // 12 here

        const n_newInList_inItemScale_arr = [n_sumNewInEachList_inUnitScale_list1_singular*n_itemInUnit_singular,...JRR(n_sumNewInEachList_inUnitScale_listRested_singular*n_itemInUnit_singular,n_lists_singular-1)]; // [15*3, 12*3, 12*3...12*3]
        const n_fromPriorInList_inItemScale_arr = [0,...JRR(n_howMuchMoreUnitSpecialForList1_inUnitScale_forFnn_forAll_singular*n_itemInUnit_singular , n_lists_singular-1)];//[0,3*3, 3*3...]

        // const n_fromPriorList_inItemScale_2ElementArr_List1_ListRest = [n_NumAllUnit_exceptOverlapInCurrentList_InUnitScale_perList_singular - ] 
        
        // const n_fromPriorList_inItemScale = n_newInList_inItemScale_arr.map(inow=>inow)

        ////////////////
        ///I had a mental breakdown. I will not write the following according to my syntax above (the syntax for initial test) 
        // The following is for pre assign final test index 
        const n_newInList_inItemScale_finaltoPatch_f_r_arr =  [15,...JRR(12,9)].map(i=>i*n_itemInUnit_singular*finalTest_PortionItemUseInType_singular);//*3* 2/3
        // const n_newInList_inItemScale_finalToPatch_b_arr = [...JRR(12,9),15].map(i=>i*n_itemInUnit_singular*finalTest_PortionItemUseInType_singular);///Though this is written, this is not used below
        
        const n_newInList_inItemScale_finaltoPatchDouble_f_r_arr = n_newInList_inItemScale_finaltoPatch_f_r_arr.map(i=>i*2); //[15*3* 2/3 *2, 12*3* 2/3 *2 ,12*3* 2/3 *2,... ]
        const n_newInList_inItemScale_finaltoPatchDouble_now_arr = ['f','r'].includes(condi) ? n_newInList_inItemScale_finaltoPatchDouble_f_r_arr : n_newInList_inItemScale_finaltoPatchDouble_f_r_arr.reverse(); //[15*3* 2/3 *2, 12*3* 2/3 *2 ,12*3* 2/3 *2,... ]

        // const n_newInList_inItemScale_finaltoPatchDouble_b_arr = n_newInList_inItemScale_finalToPatch_b_arr.map(i=>i*2); //[10*3*2, 8*3*2,8*3*2,... ]
        console.log("n_newInList_inItemScale_finaltoPatch_f_r_arr",n_newInList_inItemScale_finaltoPatch_f_r_arr)
        

        //The following number is also total number of pictures that will be used in backward condition
        const n_itemFinalTest_total_singular = sum(n_newInList_inItemScale_finaltoPatchDouble_f_r_arr) ; //=around 480 ; sum all numbers in the array; this has been doubled; 240 new pics in intial test
        // const n_itemFinalTest_b_singular = sum(n_newInList_inItemScale_finaltoPatchDouble_b_arr) ; //=around 480 ; sum all numbers in the array; this has been doubled; 240 new pics in intial test

        // forward and backward list order (reverse outer array
        const finalTestIndex_forward_arr = generateTestPositions(n_newInList_inItemScale_finaltoPatchDouble_f_r_arr).map(i=>i+1);//e.g., [[2,1...] ,[14,11,...],]
        const finalTestIndex_backward_arr = [...finalTestIndex_forward_arr].reverse();
        const finalTestIndex_random_flat_arr = shuffledRange(n_itemFinalTest_total_singular).map(i=>i+1);
        const finalTestIndex_random_arr = n_newInList_inItemScale_finaltoPatchDouble_f_r_arr.reduce(
            ([res, i], size) => [ [...res, finalTestIndex_random_flat_arr.slice(i, i + size)], i + size ],
            [[], 0]
        )[0]; //making the flat array to become a nested one like the two above

        let finalTestIndex_arr;//this store and the next will be popped
        //check the following if it assigns globally
        if (condi==='f') finalTestIndex_arr = finalTestIndex_forward_arr;
        if (condi==='b') finalTestIndex_arr = finalTestIndex_backward_arr;
        if (condi==='r') finalTestIndex_arr = finalTestIndex_random_arr;
        const finalTestIndex_arr_shallowCopy =  [...finalTestIndex_arr]; //This is used to be popped


        console.log("finalTestIndex_forward_arr",finalTestIndex_forward_arr)
        console.log("finalTestIndex_backward_arr",finalTestIndex_backward_arr)
        console.log("finalTestIndex_random_arr",finalTestIndex_random_arr)

        var preloass= {
            type: jsPsychPreload,
            images: picnames_rand.slice(0,n_itemFinalTest_total_singular).map(i_pic=>picdir+i_pic).concat(picdir+"blank.png",picdir+"correct.jpg",picdir+"Incorrect.jpg"),
            message: "loading pictures...",
            show_detailed_errors: false,
            error_message: "The experiment failed to load due to some glitch. The experiment has to end now",
            on_error: function(filepath){
            window.onbeforeunload = null;
            window.location="https://www.google.com"
            window.close = true
            jsPsych.endExperiment();
            }

        }
        timeline.push(preloass)

            // const n_eachTypeSize_InWholeExp_inItemScale_arr=[120, 120, 30, 30, 30, 39]
            // const TypeNames_arr=['n_A','n_B','n_Dn','n_Cn','n_Fnn','n_Fn'];


            
        /******
         * Algorithems below, 334 lines in total
        ******/
       //This is a var because it will be popped out
        var picnames_rand_MasterPool_initialPlusFinal_obj_ofArr = chunkToObject(picnames_rand,n_eachTypeSize_InWholeExp_inItemScale_arr.map(i=>(i+i*finalTest_PortionItemUseInType_singular)),TypeNames_arr); //i+i*finalTest_PortionItemUseInType_singular is for adding final test items
        // A: (120*  1+2/3): picname1, picname2,...
        // B: (120*  1+2/3)
        // Cn....
        const picnames_rand_MasterPool_initial_obj_ofArr = Object.fromEntries(Object.entries(picnames_rand_MasterPool_initialPlusFinal_obj_ofArr).map(([key, value])=>[key, value.splice(0,Map_NameToTypeSize_initial.get(key))]));//from position 0, remove n {A: Array(120), B: Array(120), Dn: Array(30), Cn: Array(30), Fnn: Array(30), …}
        const picnames_rand_MasterPool_finalFoil_obj_ofArr = picnames_rand_MasterPool_initialPlusFinal_obj_ofArr; //{A: Array(80), B: Array(80), Dn: Array(20), Cn: Array(20), Fnn: Array(20), …}
        const picnames_rand_MasterPool_finalFoil_obj_ofArr_shallowCopy = {...picnames_rand_MasterPool_initialPlusFinal_obj_ofArr} ; //this will be directly used in later assignment of study and test object, and will not be condensed into ArrObj as for initial test
        //because the original object's array has been spliced
        // const picnames_rand_MasterPool_final_obj_ofArr = TypeNames_arr.map(iname=>)
        // console.log("nowtest,")

        console.log('Design_TypeAll_objOfObj_initial',Design_TypeAll_objOfObj_initial)
        console.log("picnames_rand_MasterPool_initial_obj_ofArr",picnames_rand_MasterPool_initial_obj_ofArr,picnames_rand_MasterPool_finalFoil_obj_ofArr);
        
        // Initialize arrays, its key would be the types and its value would an object be the intialized 
        // typeArry = type : obj 
        //this is the time when the object is firstly initialized. 
        

        // It will becomes: {A: Array(10), B: Array(10), Dn: Array(10), Cn: Array(10), Fnn: Array(10), …};
        // A.0 key"0": Array(12 objects), A.1 key "1": Array(....
        // B.0 key"0": Array().... 
        //Notice!! The following initialize for initial only
        const master_obj_arr_arrObj_initial =  Object.fromEntries(TypeNames_arr.map(name => [name, []]));//TypeArray, stores that for intial 

        for (const type of TypeNames_arr) {

            const TC = Design_TypeAll_objOfObj_initial[type].type_comment;
            const Code1 = Design_TypeAll_objOfObj_initial[type].type_code_studiedCurr;
            const Code2 = Design_TypeAll_objOfObj_initial[type].type_code_testiedCurr;
            const Code3 = Design_TypeAll_objOfObj_initial[type].type_code_testiedNext;
            const size_inList_inUnitScale_newInList = Design_TypeAll_objOfObj_initial[type].size_inList_inUnitScale_newInList ;
            // const size_inList_inUnitScale_newPosFinal = ['f','r'].includes(condi) ? Design_TypeAll_objOfObj_initial[type].size_inList_inUnitScale_newPosFinal_f_r : Design_TypeAll_objOfObj_initial[type].size_inList_inUnitScale_newPosFinal_b ; //this line didn't consider conditions other than f, b, r; =[a,b,c] 3 elements array
            
            const nitem_list1 =  size_inList_inUnitScale_newInList[0] * n_itemInUnit_singular; //store for later easier use

            for (let i = 0; i < n_lists_singular; i++) {
                // Slice correct portion

                //The following step initialize the picNames_listi_typeX_initial array in making it have the correct number items and an id of each item of each list 
                // picNames_listi_typeX_initial
                let picNames_listi_typeX_initial;
                //Warning right here, check later if error
                if (i===0){ //list 1, special right here
                    picNames_listi_typeX_initial = picnames_rand_MasterPool_initial_obj_ofArr[type].slice(0, nitem_list1); //e.g. length 4 for Fn,  4 for A
                }else{
                    picNames_listi_typeX_initial = picnames_rand_MasterPool_initial_obj_ofArr[type].slice( nitem_list1 + (i-1)*size_inList_inUnitScale_newInList[1]*n_itemInUnit_singular, nitem_list1 + i*size_inList_inUnitScale_newInList[1]*n_itemInUnit_singular); //e.g. length 1 for Fn., 4 for A
                }
                
                

                //Following are for picking the item used for final test
                const picNames_toPatch_listi_typeX = Math.floor(picNames_listi_typeX_initial.length * finalTest_PortionItemUseInType_singular); 
                const allIndices = Array.from({ length: picNames_toPatch_listi_typeX }, (_, inow) => inow);//give array of length n, array values to be inow (1 to n), bassically range(1,n)
                // console.log("Indices:::",picNames_toPatch_listi_typeX,allIndices);

                // Shuffle the index array and pick first picNames_toPatch_listi_typeX
                const finalTestIndices = allIndices.sort(() => Math.random() - 0.5).slice(0, picNames_toPatch_listi_typeX);
                const chosenFinalSet = new Set(finalTestIndices);

                // console.log("type",type,"i",i)
                // console.log("listitems",picNames_listi_typeX_initial)
                // Map into objects
                // console.log("type",finalTestIndices,chosenFinalSet,picNames_listi_typeX_initial)
                const master_arrObj_typei_listi = picNames_listi_typeX_initial.map((id_picName, idx) => ({
                    type_comment: TC,
                    type_code_studiedCurr : Code1,
                    type_code_testiedCurr : Code2,
                    type_code_testiedNext : Code3,
                    id_picName: id_picName,
                    id_picDir: picdir + id_picName,
                    stimulusConditions : type, //condition for the whole exp, ABC, etc
                    wordcondi : condi,
                    anRepeatedItem: ['Cn','Dn','Fnn'].includes(type) ? true : false,
                    current_assignmentTypesWithinList: null,//T_target/T_foil/T_nontarget
                    listNum_firstAppear_initial: i+1,
                    listNum_finalOrder: null,
                    currentTask: null,//study/test
                    studyPos_appear1_initial: null,
                    testPos_appear1_initial: null,
                    is_studied_appear1_initial: null,
                    is_tested_appear1_initial: null,
                    studyPos_appear2_initial: null,
                    testPos_appear2_initial: null,
                    is_studied_appear2_initial: null,
                    is_tested_appear2_initial: null,
                    studyPos_appear0_initial: null,
                    testPos_appear0_initial: null,
                    is_studied_appear0_initial: null,
                    is_tested_appear0_initial: null,
                    is_currentObjAppear1: null,
                    num_CurrObjAppear: null,
                    testPos_final: null,//initialize to be 0
                    stimulusConditionName_nPlusOneTrial: null,//initialize to be 0
                    is_chosenFinal: chosenFinalSet.has(idx), //for backward condi, it's firstly chosen in list 1, for example, but it will be popped with a final index in the later for loop  
                    listNum_currTest_initial: null,
                    is_old: null,
                    correct_response_key: null,
                    is_finalFoil: false
                }));

                master_obj_arr_arrObj_initial[type].push(master_arrObj_typei_listi);
                // master_obj_arr_arrObj_initial[type].push(master_arrObj_typei_listi);
            };

        }

        //line 338 for idxs;
        // testpos=picnames_rand_MasterPool_finalFoil_obj_ofArr[iname]
        let master_obj_arrObj_finalFoil = {};
        TypeNames_arr.forEach((iname,idx)=>{
            master_obj_arrObj_finalFoil[iname] = picnames_rand_MasterPool_finalFoil_obj_ofArr[iname].map((ipic,idx_pic)=>{
                return({
                    type_comment: "final Foil",
                    type_code_studiedCurr : null,//not valid, this is for initial test
                    type_code_testiedCurr : null,//not valid
                    type_code_testiedNext : null,//not valid
                    id_picName: ipic,
                    id_picDir: picdir + ipic,
                    stimulusConditions : "FF", //FF stand for final foil
                    wordcondi : condi,
                    anRepeatedItem: false,
                    current_assignmentTypesWithinList: "F",//T_target/T_foil/T_nontarget in initial test, but different here
                    listNum_firstAppear_initial: null,//not valid, this is different from initial above
                    listNum_finalOrder: null,//not known here, but need to assign later
                    currentTask: "final_test",//study/test; must be final test
                    studyPos_appear1_initial: null,//not valid all below null
                    testPos_appear1_initial: null,
                    is_studied_appear1_initial: null,
                    is_tested_appear1_initial: null,
                    studyPos_appear2_initial: null,
                    testPos_appear2_initial: null,
                    is_studied_appear2_initial: null,
                    is_tested_appear2_initial: null,
                    studyPos_appear0_initial: null,
                    testPos_appear0_initial: null,
                    is_studied_appear0_initial: null,
                    is_tested_appear0_initial: null,
                    is_currentObjAppear1: null,
                    num_CurrObjAppear: 1, //will only appear once
                    testPos_final: null,//will assign later
                    stimulusConditionName_nPlusOneTrial: "FF" ,//will not have another name
                    is_chosenFinal: true, //this is different from initial above
                    listNum_currTest_initial: 0,//doesn't exist; this is different from initial above
                    is_old: false, //necessarily new in final test
                    correct_response_key: "f", //must be new in final test, thus using f key to response
                    is_finalFoil: true //diff
                })
            })
        });
        const master_obj_arrObj_finalFoil_shallowCopy = {...master_obj_arrObj_finalFoil};
        
    

        // const master_obj_arr_arrObj_initial_final = Object.fromEntries(TypeNames_arr.map(name => [name, []]))


        console.log('master_obj_arr_arrObj_initial',master_obj_arr_arrObj_initial);//TypeArray
        // const picnames_rand_MasterPool_initial_obj_ofArr = Object.fromEntries(Object.entries(picnames_rand_MasterPool_initialPlusFinal_obj_ofArr).map(([key, value])=>[key, value.splice(0,Map_NameToTypeSize_initial.get(key))]));

        //example: [ [ {}, {}, ... 30 ], ...10 ];  // 10 lists of 30 study objects
        let study_lists_arrArrObj_inUse = [];//array of objects
        let test_lists_arrArrObj_inUse = [];
        
        // let AllTargetFinalPos_store_map = new Map();
        // console.log("Ss",master_obj_arr_arrObj_initial)
        // let finalTest_lists_arr_arrObj = [];
        let finalTest_lists_arrObj_flat = new Array(n_itemFinalTest_total_singular);


        for (let ilist = 0; ilist < n_lists_singular; ilist++){
            // console.log("first",ilist)
            // Combine items for this list
            let finalTest_lists_arrObj = [];

            const A_items = master_obj_arr_arrObj_initial.A[ilist];
            const B_items = master_obj_arr_arrObj_initial.B[ilist];
            const Cn_items = master_obj_arr_arrObj_initial.Cn[ilist];
            const Dn_items = master_obj_arr_arrObj_initial.Dn[ilist];
            const Fn_items = master_obj_arr_arrObj_initial.Fn[ilist];
            const Fnn_items = master_obj_arr_arrObj_initial.Fnn[ilist];
            const Dn_priorList_items = ilist!==0 ? master_obj_arr_arrObj_initial.Dn[ilist-1] : undefined; 
            const Cn_priorList_items = ilist!==0 ? master_obj_arr_arrObj_initial.Cn[ilist-1] : undefined;
            const Fnn_priorList_items = ilist!==0 ? master_obj_arr_arrObj_initial.Fnn[ilist-1] : undefined;

            // Define study and test for this list
            let study = deepcopyarobj(shuffleArray([...A_items, ...B_items, ...Cn_items, ...Dn_items]));//Cn,Dn goes to next; A, B current 
            let test = deepcopyarobj(shuffleArray(
                ilist === 0
                    ? [...B_items, ...Dn_items, ...Fn_items, ...Fnn_items]
                    : [...B_items, ...Dn_items, ...Fn_items, ...Fnn_items, ...Dn_priorList_items, ...Cn_priorList_items, ...Fnn_priorList_items]
            ));//(B Dn) from current; (Fnn_l,Cn_l,Dn,l) from last list; (Fn, Fnn) current new            

            //In the following, I will assign types with their n+1 trial name:
            // A, Cn+1, B, Dn+1 || B, Dn+1, Dn, Cn, Fnn+1, Fn+1, Fnn 
            // let icount = 0;
            // ilist===1 ? console.log("study:::", study) : null;
            let addobjnow = false;
            let obj_iFinalFoil = {};
            study.forEach((obj, idx) => {//only type A, Cn, B, Dn

                currAssign = obj.stimulusConditions;
                if (['B','A'].includes(currAssign)){
                    currAssign_nPlusOneTrial = currAssign;
                    // obj.stimulusConditionName_nPlusOneTrial = currAssign;
                }else if (['Cn','Dn'].includes(currAssign)){
                    currAssign_nPlusOneTrial = currAssign + "+1";
                    // obj.stimulusConditionName_nPlusOneTrial = currAssign + "+1";
                }

                if (['f','r'].includes(condi)){
                    if (obj.is_chosenFinal){

                        addobjnow = true;
                    }else{
                        obj.testPos_final = 0;
                    }
                    // if (ilist===1){ 
                    //         console.log("studyobj",idx, obj.testPos_final,obj)
                    // }
                }else if ('b'===condi){
                    if (['A','B'].includes(currAssign_nPlusOneTrial)){

                        if (obj.is_chosenFinal){

                            addobjnow = true;
                        }else{
                            obj.testPos_final = 0;
                        }
                    }else if (['Cn+1','Dn+1'].includes(condi)) {
                        obj.testPos_final = "don't konow yet";
                        if (ilist === (n_lists_singular-1)){

                            if (obj.is_chosenFinal){

                                addobjnow = true;
                            }else{
                                obj.testPos_final = 0;
                            }
                        }
                        //Cn+1, Dn+1 find testposition in next test pos
                    }
                }

                obj.is_old = null;
                obj.correct_response_key = null;
                obj.listNum_currTest_initial = ilist+1;
                obj.stimulusConditionName_nPlusOneTrial = currAssign_nPlusOneTrial;

                
                obj.current_assignmentTypesWithinList = ['A','Cn'].includes(obj.stimulusConditions) ? "T_target" : "T_nontarget"; // keep this for now
                obj.is_currentObjAppear1 = true;
                obj.num_CurrObjAppear = 1;

                obj.studyPos_appear1_initial = idx + 1;
                obj.testPos_appear1_initial = obj.current_assignmentTypesWithinList==="T_target" ? test.findIndex(iobj=>iobj.id_picName===obj.id_picName)+1 : 0;
                obj.is_studied_appear1_initial = true;
                obj.is_tested_appear1_initial = obj.testPos_appear1_initial === 0 ? false : true;

                obj.studyPos_appear2_initial = 0;
                obj.testPos_appear2_initial = obj.anRepeatedItem ? "don't know here, assign later" : 0;
                obj.is_studied_appear2_initial = false;
                obj.is_tested_appear2_initial = obj.anRepeatedItem ? "don't know here, assign later" : false; 

                obj.studyPos_appear0_initial = obj.studyPos_appear1_initial;
                obj.testPos_appear0_initial = obj.testPos_appear1_initial;
                obj.is_studied_appear0_initial = obj.is_studied_appear1_initial;
                obj.is_tested_appear0_initial = obj.is_tested_appear1_initial;

                obj.currentTask = "study";


                if (addobjnow){
                    obj.testPos_final =  finalTestIndex_arr_shallowCopy[ilist].pop(1);
                    obj.listNum_finalOrder = getListForPosition(obj.testPos_final, n_newInList_inItemScale_finaltoPatchDouble_now_arr);

                    obj_iFinalFoil = master_obj_arrObj_finalFoil_shallowCopy[currAssign].pop(1);
                    obj_iFinalFoil.testPos_final = finalTestIndex_arr_shallowCopy[ilist].pop(1);
                    obj_iFinalFoil.listNum_finalOrder = getListForPosition(obj_iFinalFoil.testPos_final, n_newInList_inItemScale_finaltoPatchDouble_now_arr);

                    new_obj_store = deepcopyobj(obj);
                    new_obj_store.is_old=true;
                    new_obj_store.currentTask= "final_test";
                    new_obj_store.correct_response_key = 'j';
                    new_obj_store.is_studied_appear0_initial = null;
                    new_obj_store.is_tested_appear0_initial = null;
                    new_obj_store.listNum_currTest_initial = null;
                    new_obj_store.studyPos_appear0_initial= null;
                    new_obj_store.testPos_appear0_initial= null;
                    new_obj_store.type_code_studiedCurr= null;
                    new_obj_store.type_code_testiedCurr= null;
                    new_obj_store.type_code_testiedNext= null;


                    finalTest_lists_arrObj_flat[obj.testPos_final] = new_obj_store;
                    finalTest_lists_arrObj_flat[obj_iFinalFoil.testPos_final] = obj_iFinalFoil
                    console.log(new_obj_store,obj_iFinalFoil)
                }

            });

            // A, Cn+1, B, Dn+1 || B, Dn+1, Dn, Cn, Fnn+1, Fn+1, Fnn 
            // console.log(study,test)
            // ilist===1 ? console.log("test:::", test) : null;
            addobjnow = false;
            obj_iFinalFoil = {};
            test.forEach((obj, idx) => {

                currAssign = obj.stimulusConditions;

                if (['B','Fn'].includes(currAssign)){
                    currAssign_nPlusOneTrial = currAssign;
                    if (currAssign==='Fn'){//the name of Fn is special
                        currAssign_nPlusOneTrial = currAssign + "+1"
                    }
                }else if (['Cn','Dn','Fnn'].includes(currAssign)){

                    if (crrObjListNum_jsidx === ilist){
                        currAssign_nPlusOneTrial = currAssign + "+1" ;
                    }else{
                        currAssign_nPlusOneTrial = currAssign
                        obj.type_comment = obj.type_comment + ", from last trial"
                    }
                     //when ilist=1; all obj listNum_firstAppear_initial=1,thus no item is named Cn, Dn or Fnn, they are all named Cn+1, Dn+1, Fnn+1, so they won't go through the following finding of [ilist-1], the following code doesn't have a problem
                }

                curr_nPlusOneTrial_itemName = obj.stimulusConditionName_nPlusOneTrial;

                if (['f','r'].includes(condi)){
                    if (['Fnn+1','Fn+1'].includes(currAssign_nPlusOneTrial)){

                        if (obj.is_chosenFinal){
                            
                            addobjnow = true;
                        }else{
                            obj.testPos_final = 0;
                        }
                        // if (ilist===1){ 
                        //     console.log("testobj", idx,obj.testPos_final,obj)
                        // }
                    }else if (['B','Dn+1'].includes(currAssign_nPlusOneTrial)){
                        obj.testPos_final = study.find(istudy=>istudy.id_picName === obj.id_picName).testPos_final;//tricky findout here
                    }else if (['Dn','Fnn'].includes(currAssign_nPlusOneTrial)){
                        obj.testPos_final = test_lists_arrArrObj_inUse[ilist-1].find(itest=>itest.id_picName === obj.id_picName).testPos_final;
                    }else if ('Cn'===currAssign_nPlusOneTrial){
                        obj.testPos_final = study_lists_arrArrObj_inUse[ilist-1].find(istudy=>istudy.id_picName === obj.id_picName).testPos_final;
                    }

                    
                }else if ('b'===condi){
                    if (['Dn','Cn','Fnn','Fn+1'].includes(currAssign_nPlusOneTrial)){

                        if (obj.is_chosenFinal){
                            
                            addobjnow = true;
                        }else{
                            obj.testPos_final = 0;
                        }
                        // icount ++;
                    }else if (['B','Dn+1'].includes(currAssign_nPlusOneTrial)){
                        obj.testPos_final = study.find(istudy=>istudy.id_picName = obj.id_picName).testPos_final;
                    }else if ('Fnn+1' === currAssign_nPlusOneTrial){
                        obj.testPos_final = "don't know yet";
                        if (ilist === (n_lists_singular-1)){

                            if (obj.is_chosenFinal){

                                addobjnow = true;
                            }else{
                                obj.testPos_final = 0;
                            }
                            // obj.testPos_final = finalTestIndex_arr_shallowCopy[ilist].pop(1);
                            // finalTest_lists_arrObj.push(master_obj_arrObj_finalFoil_shallowCopy.pop(1))
                        }
                    }
                } 


                if (obj.is_currentObjAppear1) { //list 1 only go throug this condition 

                    obj.num_CurrObjAppear = 1;
                    obj.studyPos_appear1_initial = study.findIndex(iobj=>iobj.id_picName===obj.id_picName)+1;
                    obj.testPos_appear1_initial = idx + 1;
                    obj.is_studied_appear1_initial = obj.studyPos_appear1_initial === 0 ? false : true;
                    obj.is_tested_appear1_initial = true;

                    obj.studyPos_appear2_initial = 0; 
                    obj.testPos_appear2_initial = obj.anRepeatedItem ? "don't know here, assign later" : 0;//restricted to only type 'Cn+1','Dn+1'
                    obj.is_studied_appear2_initial = false;
                    obj.is_tested_appear2_initial = obj.anRepeatedItem ? "don't know here, assign later" : false; 

                    obj.studyPos_appear0_initial = obj.studyPos_appear1_initial;
                    obj.testPos_appear0_initial = obj.testPos_appear1_initial;
                    obj.is_studied_appear0_initial = obj.is_studied_appear1_initial;
                    obj.is_tested_appear0_initial = obj.is_tested_appear1_initial;
                }else{//only possible to be Dn, Cn, Fnn, when they were the second appear
                    // console.log(ilist,obj,study_lists_arrArrObj_inUse[ilist-1].find(iobj=>iobj.id_picName===obj.id_picName))
                    obj.num_CurrObjAppear=2;
                    if (currAssign_nPlusOneTrial !== "Fnn"){
                        obj.studyPos_appear1_initial = study_lists_arrArrObj_inUse[ilist-1].find(iobj=>iobj.id_picName===obj.id_picName).studyPos_appear1_initial;
                    }else{
                        obj.studyPos_appear1_initial = 0;
                    }

                    if (currAssign_nPlusOneTrial !== "Cn"){
                        console.log(obj,test_lists_arrArrObj_inUse[ilist-1].find(iobj=>iobj.id_picName===obj.id_picName))
                        obj.testPos_appear1_initial = test_lists_arrArrObj_inUse[ilist-1].find(iobj=>iobj.id_picName===obj.id_picName).studyPos_appear1_initial;
                    }else{
                        obj.testPos_appear1_initial = 0;
                    }
                    obj.is_studied_appear1_initial = obj.studyPos_appear1_initial === 0 ? false : true;
                    obj.is_tested_appear1_initial = obj.testPos_appear1_initial === 0 ? false : true;

                    obj.studyPos_appear2_initial = 0;
                    obj.testPos_appear2_initial = idx + 1;
                    obj.is_studied_appear2_initial = false;
                    obj.is_tested_appear2_initial = true; 

                    obj.studyPos_appear0_initial = obj.studyPos_appear2_initial;
                    obj.testPos_appear0_initial = obj.testPos_appear2_initial;
                    obj.is_studied_appear0_initial = obj.is_studied_appear2_initial;
                    obj.is_tested_appear0_initial = obj.is_tested_appear2_initial;
                }

                obj.currentTask = "test";

                obj.listNum_currTest_initial = ilist+1;
                crrObjListNum_jsidx = obj.listNum_firstAppear_initial -1;

                obj.stimulusConditionName_nPlusOneTrial = currAssign_nPlusOneTrial;

                // is_currentObj_PriorItem = obj.listNum_firstAppear_initial !== ilist;
                obj.is_currentObjAppear1 = crrObjListNum_jsidx === ilist;

                curr_isTarget = ['B','Dn'].includes(obj.stimulusConditions) &&  crrObjListNum_jsidx===ilist ? true : false;
                obj.current_assignmentTypesWithinList = curr_isTarget ? "T_target" : "T_foil"; 
                // console.log(il)

                obj.is_old = obj.current_assignmentTypesWithinList === curr_isTarget;
                obj.correct_response_key = curr_isTarget ? 'j' : 'f';

            });
 
            study_lists_arrArrObj_inUse.push(study);
            test_lists_arrArrObj_inUse.push(test);
            // finalTest_lists_arr_arrObj.push(finalTest_lists_arrObj);
        };

        console.log("finalTestIndex After pop:",finalTestIndex_arr_shallowCopy)
        console.log("finaltest_arrobj_inuse",finalTest_lists_arrObj_flat)

        console.log("studylist",study_lists_arrArrObj_inUse)
        console.log("testlist",test_lists_arrArrObj_inUse)
        

        //Assign testPos_appear2_initial = obj.anRepeatedItem ? "don't know here, assign later" : 0;
        /// is_tested_appear2_initial
        //Though maybe a single property function call could handle the following task, the for loop is kept and used because more stuff might be add in later in this part. A for loop will be easier for later usage. 

        // let finalTest_lists_arrObj = [];
        // let finalTestPositionSet = new Map();
        // let itempnow=0;
        
        //finalTest_lists_arr_arrObj
        for (let n = 0; n < n_lists_singular ; n++) {

            concat_arr = [...study_lists_arrArrObj_inUse[n], ...test_lists_arrArrObj_inUse[n]];
            // finalTestMapOfMap_ListKey.set(n,concat_arr) 
            if (n < n_lists_singular - 1){
                const nextTestList = test_lists_arrArrObj_inUse[n + 1];

                // Create a map: id → index in next test list
                const nextTestMap = new Map();
                nextTestList.forEach((obj, idx) => {
                    nextTestMap.set(obj.id_picName, obj);
                });
                
                // Now go through current list's study and test objects,
                // Assign the next list test pos in both study and test 
                // testPos_appear2_initial
                for (const obj of concat_arr){

                    const nextObj = nextTestMap.get(obj.id_picName);
                    obj.testPos_appear2_initial = nextObj ? nextObj.testPos_appear1_initial : 0;
                    obj.is_tested_appear2_initial = nextObj ? nextObj.testPos_appear1_initial !==0  : false;

                    if (condi==="b"){ //this could be moved to the previous for loop as well, but is instead written here for better clarity
                        if (['Cn+1','Dn+1','Fnn+1'].includes(obj.stimulusConditionName_nPlusOneTrial)){
                            obj.testPos_final = nextObj.testPos_final;
                        };
                    }
                }
            }else{//list 10
                for (const obj of concat_arr){

                    obj.testPos_appear2_initial = 0;
                }
            };

            // console.log(n, finalTest_lists_arrObj.length, study_lists_arrArrObj_inUse[n].length, concat_arr)

        };



        //The following is a little mistaken right now because it is a flat array. 
        // let finalTest_lists_arrArrObj_inUse = deepcopyarobj(finalTest_lists_arrObj);
        // const propertiesToRemove = ['is_currentObjAppear1',"is_studied_appear0_initial","is_tested_appear0_initial","listNum_currTest_initial","stimulusConditionName_nPlusOneTrial","num_CurrObjAppear","studyPos_appear0_initial","testPos_appear0_initial"]
        //type comment here is kept but is a little mistaken for the last part "from last trial";
        // for (const obj of finalTest_lists_arr_arrObj) {
        //     obj.currentTask = "finaltest";
        //     // propertiesToRemove.forEach(prop => delete obj[prop]);
        // };
        // console.log("finalTest_lists_arrArrObj_inUse",finalTest_lists_arr_arrObj)

    //********************************************************************************************************
    //                    Experiment variables - experiment start now
    //********************************************************************************************************
    //
    // .
    //.
    // 
    //
    //********************************************************************************************************

    var enter_fullscreen = {
    // type: jsPsychFullscreen,
    // fullscreen_mode: true
    
        type: jsPsychFullscreen,
        fullscreen_mode: true,
        message: `To start the experiment, please enter fullscreen mode.  <p>You should not exit fullscreen until you finish the experiment. </p> <br><br>Press 'enter' to continue`,
        on_load:function(){
            document.addEventListener('keydown', function (event) {
            // Check if the pressed key is Enter (key code 13)
            if (event.key === 'Enter') {
                // Simulate a click event on the hidden "Continue" button
                var continueButton = document.getElementById('jspsych-fullscreen-btn');
                // console.log(continueButton)
                if (continueButton) continueButton.click();
            }
        });
        }
    }

    var handleFullscreenChange = true;
    is_inst_fullscreen? 
    document.addEventListener('fullscreenchange', function(event) {
        if (handleFullscreenChange&&!document.fullscreenElement) {
            // Handle the case when the user exits fullscreen during the experiment
            // jsPsych.enterFullscreen(); // Re-enter fullscreen
            alert('Please keep the experiment in fullscreen mode. Press F11. Or your data might not be valid');
            jsPsych.data.addProperties({
                is_changedfullscreen: 1
            });
            // timeline.push(enter_fullscreen)
        }
    }) : null;


    is_inst_fullscreen? window.onbeforeunload = function() {
        return "Do you really want to leave?";
        //if we return nothing here (just calling return;) then there will be no pop-up question at all
        //return;
    } : null;

    var browser_check = {
        type: jsPsychBrowserCheck,
        on_finish: function(data){
            // window.onbeforeunload = null;
            console.log(data.browser)
            if (!(["chrome","Chrome"].includes(data.browser))){
            // console.log(data.browser)
                alert("You must use Chrome as your browser! You may switch your browser and come back later.")
                window.onbeforeunload = null;
                window.location="https://www.google.com"
                window.close = true
            } else if (data.mobie){
                alert("You must use a desktop/laptop computer to participate in this experiment.")
                window.onbeforeunload = null;
                window.location="https://www.google.com"
                window.close = true
            }
        }
        
    };

    var enterid = {
        type: jsPsychSurveyText,
        questions: [{prompt: "<p color:black>What is your prolific ID?</p> <p> Press 'enter' to continue after filling in your ID.",required:true}],
        on_load:function(){
            var continueButton = document.getElementById('jspsych-survey-text-next');
            if (continueButton) continueButton.style.display='block !important'
            console.log(continueButton)
        },
        on_finish:function(data){
            data.id=data.response["Q0"];
            // check below
            // if (oldids.includes(data.id)) {
            //     alert(`
            //     Dear participant,
                
            //     We have identified that you have previously taken part in one of our research studies, and we sincerely value your prior involvement. Regrettably, we must inform you that you are ineligible to participate in the current study once more.
                
            //     If you believe this determination to be in error, please do not hesitate to reach out to our research team. We will promptly address your concerns.
                
            //     Thank you for your understanding.
            //     `);
            //     console.log("true")
            //     window.onbeforeunload = null;
            //     window.location="https://www.google.com"
            //     window.close = true
            //     jsPsych.endExperiment();
            // }
        },
        data: {
            task: "enterid"
        }
    }

    var fixation = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: '<div style="font-size:60px;">+</div>',
        choices: "NO_KEYS",
        trial_duration: fixation_duration,
        data: {
            task: 'fixation'
        }
    };

    var instructions = {
        type: jsPsychSurveyMultiChoice,
        on_load:function(){
        // var continueButton = document.getElementById('jspsych-fullscreen-btn');
        // if (continueButton) continueButton.style.display='block'
        // console.log(continueButton)
        },
        questions: [
        {
        prompt: `<h1 style='text-align: left;color: crimson;background: white;font: caption-;''> INDIANA UNIVERSITY STUDY INFORMATION SHEET FOR RESEARCH MEMORY TEST FOR WORD AND PICTURE </h1> <br>

            <h1 style='color: black;text-align: left;background: white;font: caption;'> You are being asked to participate in a research study. Scientists do research to answer important questions that might help change or improve the way we do things in the future. This document will give you information about the study to help you decide whether you want to participate. Please read this form, and ask any questions you have, before agreeing to be in the study. This study is being conducted under the approval of the Indiana University Institutional Review Board (IRB) with protocol number 18431, including any approved amendments.</h1><br>

            <h1 style='color: black;text-align: left;background: white;font: caption;'> All research is voluntary. You can choose not to take part in this study. If  you decide to participate, you can change your mind later and leave the study at any time. You will not be penalized or lose any benefits if you decide not to participate or choose to leave the study later.</h1> <br> 

            <h1 style='color: black;text-align: left;background: white;font: caption;'> This research is intended for individuals 18 years of age or older. If you are under age 18, do not complete the survey. This research is for residents of the United States. If you are not a U.S. resident, do not complete the survey.</h1> <br> 

            <h1 style='color: black;text-align: left;background: white;font: caption;'> The purpose of this study is to investigate how people remember words and/or pictures.</h1> <br> <h1 style='color: black;text-align: left;background: white;font: caption;'> We are asking you if you want to be in this study because you registered for this study on Prolific. The study is being conducted by Dr. Richard Shiffrin, a professor in the department of Psychological and Brain Science and the Program in Cognitive Science.</h1> <br> 


            
            <h1 style='color: black;text-align: left;background: white;font: caption;'> To protect against loss of confidentiality, any identifiable information from the data that could lead back to you will be removed within two days of your completion of the study. We don’t think you will have any personal benefits from taking part in this study, but we hope to learn things that will help researchers in the future.
            </h1> <br> 
            
            <h1 style='color: black;text-align: left;background: white;font: caption;'><strong><FONT color='#CC5500'> You will be paid for participating in this study.</FONT>We pay at an hourly rate of $10.50, and the payment will be disbursed within 5 days after completing the experiment. The maximum time of taking this experiment is 120 minutes. The timer began as soon as you accessed the link to this study. <strong> <br><FONT COLOR="#CC5500"> TO BE APPROVED AND GET FULLY PAID, YOU WILL HAVE TO PAY ATTENTION TO THE INSTRUCTIONS AND SHOW THAT YOU COULD REMEMBER SOME OF THE WORDS THAT YOU STUDY. </FONT> You will receive feedback telling you whether you have been able to remember the words.</strong> </h1><br>

            <h1 style='color: black;text-align: left;background: white;font: caption;'> 
        <strong><FONT color='#CC5500'>If you agree to be in the study, you will do the following things.</FONT> First, the experiment will ask for you to input your ID in Prolific. You must use desktop or PC to do this experiment. You must use <FONT color='#CC5500'> Chrome</FONT> as your browser. In these trials, you will see a list of words to remember. After each list, you will see some digits to add up. Then type the sum. You will then be given the first two letters of a word you studied. If you can remember, type the word that begins with those two letters. </strong> 
        </h1> <br> 
            <h1 style='color: black;text-align: left;background: white;font: caption;'> We will protect your information and make every effort to keep your personal information confidential, but we cannot guarantee absolute confidentiality. No information which could identify you will be shared in publications about this study. Your personal information may be shared outside the research study if required by law. We also may need to share your research records with other groups for quality assurance or data analysis. These groups include the Indiana University Institutional Review Board or its designees, and state or federal agencies who may need to access the research records (as allowed by law). </h1><br>

            <h1 style='color: black;text-align: left;background: white;font: caption;'> If you have questions about the study or encounter a problem with the research, contact the researcher. For questions about the study, contact either Shuchun Lai at shulai@iu.edu , or Dr. Richard Shiffrin at shiffrin@indiana.edu.
            For questions about your rights as a research participant, to discuss problems, complaints, or concerns about a research study, or to obtain information or to offer input, please contact the IU Human Research Protection Program office at 800-696-2949 or at irb@iu.edu. </h1><br>
            
            <h1 style='color: black;text-align: left;background: white;font: caption;'> Thank you for agreeing to participate in our research. Before you begin, please note that the data you provide may be collected and used by Prolific as per its privacy agreement. Additionally, this research is for subjects over the age of 18*; if you are under the age of 18, please do not complete this survey.</h1><br>
            `,
        
        name: 'consent', 
        options:[`I have read and understand this information and agree to join this study. <p style='text-align: left'> Clicking to confirm, then press 'enter' to continue.</p>`],
        required: true
        }, 
    ],
    };

    if (is_inst_fullscreen) {
        timeline.push(enterid);
        timeline.push(browser_check);
        timeline.push(instructions);
        timeline.push(enter_fullscreen);
    }


    const practice_text = "practice text undefined, press enter"; //not sure if gonna use this, check later



    var flguse_ins=0;//Check this: don't know what its doing

    var prompt_instructions_practice = {
        timeline: [{
            type: jsPsychHtmlKeyboardResponse,
            stimulus: practice_text,
            post_trial_gap: posgap_duration,
            trial_duration: instruction_duration,//1hr if not 
            choices: choiceenter,
            data: {task: "instructions_practice"},
            on_start: function() {
                // Record the start time of the trial
                if (flguse_ins===0){
                    instructionsStartTime_practice = jsPsych.getTotalTime();
                    flguse_ins=1;
                    // console.log("once!")
                }
            },

        }],
        loop_function: function(data){

            // console.log()

            if (is_debug) return(false)

            //Check the following, the following has created problems
            var timeElapsed = jsPsych.getTotalTime() - instructionsStartTime_practice;
            // console.log(timeElapsed)
            timelimit = timelimit_initial_inst;
            timeleft = Math.round((timelimit-timeElapsed)/1000);
            if(timeElapsed < timelimit) {
                // Less than 10 seconds passed, continue looping
                warningfunc(`<div style="text-align:center ; font-size: larger; font-weight: bold; color: black;"><br> <br> <br> <br> <br>Please take more time to read the instructions! (${timeleft} seconds left)</div>`,warning_duration)
                return true; 
            } else {
                // 10 seconds have passed, break the loop
                return false;
            }
        }
    }



    var instructions_test = {//not used here becuase there is only one practice trial

        type: jsPsychHtmlKeyboardResponse,
        stimulus: `
        <p style='text-align: justify;color: black;background: white;font: caption-;''>
            Now you have finished the practice. When ready, start the study list with the ‘enter’ key.</p>
        `,
        post_trial_gap: posgap_duration,
        trial_duration: instruction_duration,
        choices: choiceenter
        };

    var prompt_instructions_between = {//Check this

        type: jsPsychHtmlKeyboardResponse,
        stimulus: `
        <p style='text-align: justify;color: black;background: white;font: caption-;''>
            Press the 'enter' key to see the next list of pictures. </p>
        `,
        post_trial_gap: posgap_duration,
        trial_duration: instruction_duration_between,
        choices: choiceenter
    };

    var prompt_countingfeedback = {//correct and in correct

        type: jsPsychHtmlKeyboardResponse,
        stimulus: function(){
            // console.log(jsPsych.data.get().last(1).values()[0])
            if(jsPsych.data.get().last(1).values()[0].correct)
            return("<p background:white>CORRECT!</p>")
            else return("<p background:white>INCORRECT!</p>")
        },
        choices: "NO_KEYS",
        trial_duration: feedbackmes_duration,
        data:{
            task: "promptfeedback"
        }, 
        post_trial_gap: posgap_duration
    };

    //Check this
    if (condi==='f'){mes = `ss`}
    else if (condi==="b"){mes=`ss`}
    else if (condi==="r") (mes='')

    finalint_text = `<p style='text-align: justify;color: black;background: white;font: caption-;paddingRight =30px; paddingLeft =30px;'>

        <strong>You have now completed the first part of the study. <br>
        The next part contains only tests of words. It will test for ALL the words you have seen in this study.</strong> <br><br>

        ${mes}<br><br>

    <strong>Try to respond as fast and as accurate as possible.</strong> <br><br>

    If you have read and understood these instructions, press the RETURN/ENTER key to go to the testing.`


    var flguse_final=0;
    var instructions_finaltest = {
        timeline: [{
            on_start: function() {
                // Record the start time of the trial
                if (flguse_final===0){
                    instructionsStartTime = jsPsych.getTotalTime();
                    flguse_final=1;
            }
            },
            type: jsPsychHtmlKeyboardResponse,
            stimulus: finalint_text,
            post_trial_gap: posgap_duration,
            trial_duration: instruction_duration,
            choices: keychoice_finaltest,
            data: {
                task: "finalt_instructions"
            }
            // minimum_valid_rt:2000,
            // response_ends_trial:false
        }],

        loop_function: function(data){

            // console.log()

            if (is_debug) return(false)

            var timeElapsed = jsPsych.getTotalTime() - instructionsStartTime;
            console.log(timeElapsed)
            timelimit = timelimit_finalinst; //Attention! Check here! This has been causing problems
            // timelimit = 1000;
            timeleft = Math.round((timelimit-timeElapsed)/1000);
            if(timeElapsed < timelimit) {
                // Less than 10 seconds passed, continue looping
                warningfunc(`<div style="text-align:center ; font-size: larger; font-weight: bold; color: black;"><br> <br> <br> <br> <br>Please take more time to read the instructions! (${timeleft} seconds left)</div>`,warning_duration)
                return true; 
            } else {
                // 10 seconds have passed, break the loop
                return false;
            }
        }
    }

    var ISI = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: '',
            choices: "NO_KEYS",
            trial_duration: 100,
    };   

    var prompt_digits = {

        type: jsPsychHtmlKeyboardResponse,
        stimulus: 'Summing up the digits as they appear',
        choices: "NO_KEYS",
        trial_duration: prompt_duration,
        data:{
            task: "prompt"
        },
        post_trial_gap: posgap_duration
    };

    var prompt_recall = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: 'Now judge if you have seen this pictures from the list you JUST studied before the digits',
        choices: "NO_KEYS",
        trial_duration: prompt_duration,
        data:{
          task: "prompt"
        },
        post_trial_gap: posgap_duration
    };



    var v_initialstudy_trial = {

        type: jsPsychImageKeyboardResponse,
        stimulus: JT('id_picDir'),
        choices: "NO_KEYS",
        trial_duration: study_duration, //Check this
        post_trial_gap: posgap_duration, //And check this
        data: {
            anRepeatedItem: JT("anRepeatedItem"),
            currentTask: "initial_study",
            current_assignmentTypesWithinList: JT("current_assignmentTypesWithinList"),
            is_chosenFinal: JT("is_chosenFinal"),
            is_currentObjAppear1: JT("is_currentObjAppear1"),
            is_studied_appear0_initial: JT("is_studied_appear0_initial"),
            is_studied_appear1_initial: JT("is_studied_appear1_initial"),
            is_studied_appear2_initial: JT("is_studied_appear2_initial"),
            is_tested_appear0_initial: JT("is_tested_appear0_initial"),
            is_tested_appear1_initial: JT("is_tested_appear1_initial"),
            is_tested_appear2_initial: JT("is_tested_appear2_initial"),
            listNum_currTest_initial:  JT('listNum_currTest_initial'),
            listNum_firstAppear_initial: JT("listNum_firstAppear_initial"),
            stimulusConditionName_nPlusOneTrial: JT("stimulusConditionName_nPlusOneTrial"),
            num_CurrObjAppear: JT("num_CurrObjAppear"),
            stimulusConditions: JT("stimulusConditions"),
            studyPos_appear0_initial: JT("studyPos_appear0_initial"),
            studyPos_appear1_initial: JT("studyPos_appear1_initial"),
            studyPos_appear2_initial: JT("studyPos_appear2_initial"),
            testPos_appear0_initial: JT("testPos_appear0_initial"),
            testPos_appear1_initial: JT("testPos_appear1_initial"),
            testPos_appear2_initial: JT("testPos_appear2_initial"),
            testPos_final: JT("testPos_final"),
            type_code_studiedCurr: JT("type_code_studiedCurr"),
            type_code_testiedCurr: JT("type_code_testiedCurr"),
            type_code_testiedNext: JT("type_code_testiedNext"),
            type_comment: JT("type_comment"),
            id_picName: JT("id_picName"),
            is_old: JT("is_old"),
            correct_response_key: JT("correct_response_key")
        }
    };

    var v_digitpresent = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: JT('digit_value'),
        choices: "NO_KEYS",
        trial_duration: counting_duration,
        post_trial_gap: counting_gap,
        data: {
            task: "digitPresentation", 
            presPos: JT("presPos"),
            stimulus_id: JT("digit_value"),
            sum_currList: JT("sum_currList"),
            listNum_currTest_initial: JT("listNum_currTest_initial")
        },
        on_finish: function(data){
        // console.log(digits_list_sum_itrial);
        }
    };

    var v_answer_digit = {//nondebug

        on_start: function(trial){
            if (is_showcorrect_inlog) console.log("Correct answer:",trial,trial.data.correct_response);
            if (is_debug){
                setTimeout(function () {
                jsPsych.finishTrial({
                    response: {
                        question: trial.questions[0].prompt,
                        answer: 'Skipped after ' + (10 / 1000) + ' seconds'
                    }
                });
                }, 10);
            }
        },
        type: jsPsychSurveyText,
        questions: [
            {prompt: `Please enter the sum using your number keyboard <p>Press 'enter' to continue.</p>`,required: true}
        ],
        on_finish: function(data){
            //   console.log(digits_list_sum_itrial);
            // console.log(current_digit_response)
            ans = Object.values(data.response)[0];
            // console.log(ans)
            data.correct = ans==data.correct_response
            // console.log(data.correct_response);
            data.responsesum = ans;
        },
        data: {
            task: "answer_counting",
            correct_response: JT("sum_currList"),
            // is_correct: ;
            listNum_currTest_initial: "listNum_currTest_initial"
        }
    };//check data structure of the current answer

    var answer_digit_looptrial = {
        timeline: [v_answer_digit],
        loop_function: function(data){

            // console.log()

            if (is_debug) return(false)

            var cur_response = Object.values(data.values()[0].response);
            // console.log(cur_response);
            isdigits = /^[0-9]*$/.test(cur_response);
            // console.log(isdigits);
            if(!isdigits){
                warningfunc(`<div style="text-align:center ; font-size: larger; font-weight: bold; color: black;"><br> <br> <br> <br> <br> Not Digits! </div>`,warning_duration)
                return true;
            } else {

                // currentans = data.values()[0].response;
                return false;
            }
        }
    };



    var v_initialTest_trial = {

        type: jsPsychImageKeyboardResponse,
        trial_duration: initial_test_duration,
        stimulus: jsPsych.timelineVariable("id_picDir"),
        choices: responsekeys,
        post_trial_gap: posgap_duration,
        on_start:function(trial){

            if (is_showcorrect_inlog) console.log("Correct answer:",trial,trial.data.correct_response_key);
            if (trial.data.testpos == 1){
                trial.data.accumulated_accuracy = 0;
                // trial.data.accumulated_accuracy_last = 0;
            }else {
                // document.getElementById("Div1").style.visibility = "visible";
                // console.log(jsPsych.data.getLastTrialData())
                trial.data.accumulated_accuracy = jsPsych.data.getLastTrialData().trials[0].accumulated_accuracy;
                // trial.data.accumulated_accuracy_last = jsPsych.data.getLastTrialData().trials[0].accumulated_accuracy
            }

        },

        data:{
            task: 'initialTest_response',
            anRepeatedItem: JT("anRepeatedItem"),
            currentTask: "initial_test",
            current_assignmentTypesWithinList: JT("current_assignmentTypesWithinList"),
            is_chosenFinal: JT("is_chosenFinal"),
            is_currentObjAppear1: JT("is_currentObjAppear1"),
            is_studied_appear0_initial: JT("is_studied_appear0_initial"),
            is_studied_appear1_initial: JT("is_studied_appear1_initial"),
            is_studied_appear2_initial: JT("is_studied_appear2_initial"),
            is_tested_appear0_initial: JT("is_tested_appear0_initial"),
            is_tested_appear1_initial: JT("is_tested_appear1_initial"),
            is_tested_appear2_initial: JT("is_tested_appear2_initial"),
            listNum_currTest_initial:  JT('listNum_currTest_initial'),
            listNum_firstAppear_initial: JT("listNum_firstAppear_initial"),
            stimulusConditionName_nPlusOneTrial: JT("stimulusConditionName_nPlusOneTrial"),
            num_CurrObjAppear: JT("num_CurrObjAppear"),
            stimulusConditions: JT("stimulusConditions"),
            studyPos_appear0_initial: JT("studyPos_appear0_initial"),
            studyPos_appear1_initial: JT("studyPos_appear1_initial"),
            studyPos_appear2_initial: JT("studyPos_appear2_initial"),
            testPos_appear0_initial: JT("testPos_appear0_initial"),
            testPos_appear1_initial: JT("testPos_appear1_initial"),
            testPos_appear2_initial: JT("testPos_appear2_initial"),
            testPos_final: JT("testPos_final"),
            type_code_studiedCurr: JT("type_code_studiedCurr"),
            type_code_testiedCurr: JT("type_code_testiedCurr"),
            type_code_testiedNext: JT("type_code_testiedNext"),
            type_comment: JT("type_comment"),
            id_picName: JT("id_picName"),
            is_old: JT("is_old"),
            correct_response_key: JT("correct_response_key")
        },
        prompt: function(){
            lastresp = jsPsych.data.get().last(1).values()[0]
            // console.log(lastresp)
            if (lastresp.task == "pretest_response"){
              
                return '<p color: black;background: white;><strong>"F" for new&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"J" for old</strong></p>'.concat(
                  "Your accumulated accuracy for this trial is: ").concat(
                  Math.round(lastresp.accumulated_accuracy*100)).concat("%")
            }
            else { //first trial
              
                return '<p color: black;background: white;><strong>"F" for new&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;"J" for old</strong></p>'.concat(
                  "Your accumulated accuracy for this trial is: ")
            }
        },

        on_finish: function(data){

            data.correct = jsPsych.pluginAPI.compareKeys(data.response, data.correct_response_key);
            if (data.correct) tempcrr=1; else tempcrr=0;
            data.recognition_correct = tempcrr;
            
            data.accumulated_accuracy = (data.accumulated_accuracy*(data.testPos_appear0_initial-1)+tempcrr)/data.testPos_appear0_initial;

            if (data.response == null){
                // document.getElementById("Div1").style.visibility = "hidden";
                warningfunc("<div font-size: larger; font-weight: bold; color: black;> You need to respond faster!  </div>",warning_duration)
            };

            if (data.rt < rtfastcut_duration & data.response!=null){

                // document.getElementById("Div1").style.visibility = "hidden";
                warningfunc(`<div style= "text-align:center" ; font-size: larger; font-weight: bold; color: black; class="center-screen" ><br> <br> <br> <br> <br> Too fast!  </div>`,warning_duration)
            } 
        }
        };





    //********************************************************************************************************
    //                   Initial expeirments
    //********************************************************************************************************
    //
    // .
    //.
    // 
    //
    //********************************************************************************************************
    let all_lists_initialStudy_inUse = [];

    // ntemp = 1
    for (let ilist=0; ilist < n_lists_singular; ilist++){
        all_lists_initialStudy_inUse.push({
            studies: study_lists_arrArrObj_inUse[ilist],
            tests: test_lists_arrArrObj_inUse[ilist],
            digits: digit_list_arrArrObj_inUse[ilist]
        })

    }
    // console.log()
    console.log("all_lists_initialStudy_inUse",all_lists_initialStudy_inUse)
    

    const initialTest_timeline = all_lists_initialStudy_inUse.map(function(list,list_ind){
            return {
                timeline: [
                    {
                        timeline: list_ind === 0 ? [prompt_instructions_practice] : [prompt_instructions_between]
                    },
                    {
                        timeline: [fixation]
                    },
                    {//The following are comparable to push the 'final' stuff into the timeline variable; as if creating a new timeline varible element
                        timeline: [v_initialstudy_trial],
                        timeline_variables: list.studies
                    },
                    {
                        timeline: [prompt_digits]
                    },
                    {
                        timeline: [fixation]
                    },
                    {
                        timeline: [v_digitpresent],
                        timeline_variables: list.digits
                    },
                    {
                        timeline: [answer_digit_looptrial],
                        timeline_variables: [digit_totCorrect_sum_arrObj_inUse[list_ind]]
                    },                    
                    {
                        timeline: [prompt_countingfeedback]
                    },
                    {
                        timeline: [prompt_recall]
                    },                    
                    {
                        timeline: [fixation]
                    },                    
                    {
                        timeline: [v_initialTest_trial],
                        timeline_variables: list.tests
                    }
                ]
            };
    });
    


    //this works, but doesn't work when changing to forEach
    // const initialTest_timeline = all_lists_initialStudy_inUse.map(list=>{
    //         return {
    //             timeline: [
    //                 {
    //                     timeline: [prompt_instructions_practice]
    //                 },
    //                 {
    //                     timeline: [fixation]
    //                 }
    //             ]
    //         };
    // });

    timeline.push(initialTest_timeline);
    //********************************************************************************************************
    //                    Sample Tests below
    //********************************************************************************************************
    //
    // .
    //.
    // 
    //
    //********************************************************************************************************
    // jsPsych.run(timeline.flat());



        const list1_study = [
            { image: picdir_arr[1] },
            { image: picdir_arr[2] },
            // ...
            { image: picdir_arr[3] }
            ];

        const list1_test = [
        { image: picdir_arr[2], correct_response: 'f' },
        { image: picdir_arr[3], correct_response: 'j' },
        // ...
        { image: picdir_arr[5], correct_response: 'f' }
        ];

        const list2_study = [
            { image: picdir_arr[1] },
            { image: picdir_arr[2] },
            // ...
            { image: picdir_arr[3] }
            ];

        const list2_test = [
        { image: picdir_arr[2], correct_response: 'f' },
        { image: picdir_arr[3], correct_response: 'j' },
        // ...
        { image: picdir_arr[5], correct_response: 'f' }
        ];

        const all_lists = [
        { study: list1_study, test: list1_test },
        { study: list2_study, test: list2_test }
        ];

        const study_trial = {
            type: jsPsychImageKeyboardResponse,
            stimulus: jsPsych.timelineVariable('image'),
            choices: [' '],
            trial_duration: 1000
            };

        const test_trial = {
            type: jsPsychImageKeyboardResponse,
            stimulus: jsPsych.timelineVariable('image'),
            choices: ['f', 'j'],
            data: {
                correct_response: jsPsych.timelineVariable('correct_response')
            }
            };
        
        const test_timeline = all_lists.map(list => {
            return {
                timeline: [
                {//The following are comparable to push the 'final' stuff into the timeline variable; as if creating a new timeline varible element
                    timeline: [study_trial],
                    timeline_variables: list.study,
                    randomize_order: false
                },
                {
                    timeline: [test_trial],
                    timeline_variables: list.test,
                    randomize_order: false
                }
                ]
            };
            });
        
        
        // timeline.push(test_timeline)
        //// EXPERIMENT START
        /////The followings are just a test
        






        // timeline.push(fixation);
        jsPsych.run(timeline.flat());


        //********************************************************************************************************
    //                    Functions
    //********************************************************************************************************
    //
    // Brief description of this section and its purpose.
    // Additional details or important information.
    // List of key tasks or functions performed here.
    //
    //********************************************************************************************************

function getListForPosition(testPosition, listSizes) {
    let ranges = [];
    let start = 1;  // Start position for the first list

    // Calculate cumulative ranges based on list sizes
    listSizes.forEach(size => {
        let end = start + size - 1;  // End position for the current list
        ranges.push({ start, end });
        start = end + 1;  // The start of the next list
    });

    // Check which range the testPosition falls into
    for (let i = 0; i < ranges.length; i++) {
        if (testPosition >= ranges[i].start && testPosition <= ranges[i].end) {
        return i + 1;  // Return the list number (1-based)
        }
    }
    return null;  // If the position doesn't match any list (shouldn't happen if valid)
}

//the following shuffles array while changes it's original copy
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));  // pick a random index <= i
    [array[i], array[j]] = [array[j], array[i]];    // swap
  }
  return array;
};

function shuffledRange(n) {
  const arr = Array.from({ length: n }, (_, i) => i);
  for (let i = n - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
};


function repeatedArray(x,a) {return Array.from({ length: a }, () => x)};

function generateTestPositions(lengths) {//input an array with lengthens of each subarray
  let currentPos = 0;
  let result = [];

  // Loop through the lengths array
  for (let i = 0; i < lengths.length; i++) {
    const subArrayLength = lengths[i];

    // Generate continuous range for the current subarray
    let range = [];
    for (let j = currentPos; j < currentPos + subArrayLength; j++) {
      range.push(j);
    }

    // Shuffle the positions inside the subarray
    range = shuffleArray(range);

    // Add the shuffled positions to the result array
    result.push(range);

    // Update the current position for the next subarray
    currentPos += subArrayLength;
  }

  return result;
}

function average(arr) {
    const sum = arr.reduce((acc, value) => {
        // Convert boolean to 0 or 1 for calculation
        const numericValue = typeof value === 'boolean' ? (value ? 1 : 0) : value;
        return acc + numericValue;
    }, 0);

    return sum / arr.length;
}

function sum(arr) {
  return arr.reduce((acc, num) => acc + num, 0);
}


function range(start, end)
{
    var array = new Array();
    for(var i = start; i < end; i++)
    {
        array.push(i);
    }
    return array;
}

    function deepcopyobj(obj_f){
    return (Object.assign({},obj_f))//this could've been done better with spread operator ...
    }

    function deepcopyarobj(arobj_f){
    return(range(0,arobj_f.length).map(i=>deepcopyobj(arobj_f[i])))
    }
    function randomize_ar_inside_nfar(nfar){//randomize 1*1 nonflat ar
    return range(0,nfar.length).map(i=>jsPsych.randomization.sampleWithoutReplacement(nfar[i],nfar[i].length));
    }   

function chunkToObject(arr, sizes, names) {
  if (sizes.length !== names.length) {
    throw new Error("Mismatch between number of sizes and names");
  }

  const result = {};
  let index = 0;

  for (let i = 0; i < sizes.length; i++) {
    result[names[i]] = arr.slice(index, index + sizes[i]);
    // result[names[i]] = 'sss';
    index += sizes[i];
  }

  return result;
}

function readTextFile(file) {

    const rawFile = new XMLHttpRequest();
        let content = null;
        rawFile.open("GET", file, false);
        rawFile.onreadystatechange = function () {
            if (rawFile.readyState === 4) {
                if (rawFile.status === 200 || rawFile.status === 0) {
                    content = rawFile.responseText;
                }
            }
        };
        rawFile.send(null);
        return content;
};

function warningfunc(message,timedur){

    var messageDiv = document.createElement("div");
    messageDiv.innerHTML = message;
    // messageDiv.className="jspsych-content-wrapper"
    messageDiv.style.padding = `350px 0`;
    messageDiv.style.textAlign = "center";
    messageDiv.style.margin = "0px"
    // messageDiv.style.height = "100vh";
    messageDiv.style.display = "flex";
    messageDiv.style.justifyContent = "center";
    var exp = document.getElementsByClassName("jspsych-content-wrapper")[0]
    exp.style.visibility = "hidden";
    jsPsych.pauseExperiment() 
    document.body.prepend(messageDiv);
    setTimeout(function() {
        document.body.removeChild(messageDiv); // Remove the div
        exp.style.visibility = "visible";
        jsPsych.resumeExperiment();
    }, timedur);//remove after 1.5s
}

function arrsum(ar){return(ar.reduce((a,b)=>a+b,0))};

function combinedReorderArray(reorder) {
    // let reverseReorder = reorder;
    let original = new Array(reorder.length);
    let original2 = new Array(reorder.length);
    let left = 0;
    let right = reorder.length - 1;

    for (let i = 0; i < reorder.length; i += 2) {
        if (left == right) {
            original[left] = original2[left] = reorder[i];
        } else {
            original[left] = original2[right] = reorder[i];
            // Ensure we don't go out of bounds when the original array has an odd length
            if (i + 1 < reorder.length) {
                original[right] = original2[left] = reorder[i + 1];
            }
        }
        left++;
        right--;
    }

    return [original,original2];
}



function startExperimentTimer() {

    const experimentTimerInterval = window.setInterval(function() {

        const currentTime = Date.now();
        if (currentTime - lastActivityTime > timeout) {
        alert(`
            Dear participant,

            We regret to inform you that the experiment has been terminated automatically due to exceeding the allowed time. Please close the page to finalize the results. And we kindly request you not to attempt this experiment again.

            We would like to thank you for your participation. Although you were unable to complete this particular experiment, we hope that you will consider joining us for future experiments. Thank you again for your time and effort; you may close the page now.
        `);
        clearInterval(experimentTimerInterval);
        console.log(currentTime - lastActivityTime);
        window.onbeforeunload = null;
        window.location = "https://www.google.com";
        window.close = true;
        jsPsych.endExperiment();
        }
    }, 1000);
}

    </script>